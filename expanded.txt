    Checking atspi v0.1.0 (/mnt/extra/code/rust/gtk-rs/sys/atspi)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33s

#![feature(prelude_import)]
#![no_std]
//! # ATSPI bindings
//!
//! This library contains safe Rust bindings for ATSPI
#[prelude_import]
use ::std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate libc;
#[macro_use]
extern crate bitflags;
extern crate atspi_sys;
extern crate glib_sys;
extern crate gobject_sys;
#[macro_use]
extern crate glib;
#[macro_use]
mod rt {}
mod auto {
    mod accessible {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::ptr;
        use Action;
        use Cache;
        use Collection;
        use Component;
        use Document;
        use EditableText;
        use Error;
        use Hyperlink;
        use Hypertext;
        use Image;
        use Object;
        use Role;
        use Selection;
        use StateSet;
        use Table;
        use TableCell;
        use Text;
        use Value;
        pub struct Accessible(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiAccessible>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Accessible {
            #[inline]
            fn clone(&self) -> Accessible {
                match *self {
                    Accessible(ref __self_0_0, ref __self_0_1) => Accessible(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Accessible {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Accessible(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Accessible {
            #[inline]
            fn cmp(&self, other: &Accessible) -> ::core::cmp::Ordering {
                match *other {
                    Accessible(ref __self_1_0, ref __self_1_1) => match *self {
                        Accessible(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Accessible {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Accessible {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Accessible(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Accessible {
            type GlibType = *mut atspi_sys::AtspiAccessible;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Accessible {
            type GlibType = atspi_sys::AtspiAccessible;
            type GlibClassType = atspi_sys::AtspiAccessibleClass;
            type RustClassType = AccessibleClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Accessible {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Accessible> for Accessible {
            fn as_ref(&self) -> &Accessible {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Accessible> for Accessible {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiAccessible> for Accessible {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiAccessible, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiAccessible {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiAccessible> for Accessible {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiAccessible, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiAccessible {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiAccessible>
            for Accessible
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiAccessible, Accessible>>,
                Option<Vec<*mut atspi_sys::AtspiAccessible>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Accessible],
            ) -> (*mut *mut atspi_sys::AtspiAccessible, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiAccessible);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiAccessible,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Accessible],
            ) -> (*mut *mut atspi_sys::AtspiAccessible, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiAccessible>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiAccessible;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Accessible]) -> *mut *mut atspi_sys::AtspiAccessible {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiAccessible>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiAccessible;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiAccessible>
            for Accessible
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiAccessible, Accessible>>,
                Option<Vec<*mut atspi_sys::AtspiAccessible>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Accessible],
            ) -> (*const *mut atspi_sys::AtspiAccessible, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiAccessible,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiAccessible, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Accessible],
            ) -> (*const *mut atspi_sys::AtspiAccessible, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/accessible.rs", 30u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Accessible]) -> *const *mut atspi_sys::AtspiAccessible {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/accessible.rs", 30u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiAccessible> for Accessible {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiAccessible) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/accessible.rs" , 30u32 , 1u32 ) )
                        }
                    };
                };
                Accessible(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiAccessible> for Accessible {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiAccessible) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/accessible.rs" , 30u32 , 1u32 ) )
                        }
                    };
                };
                Accessible(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiAccessible> for Accessible {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiAccessible) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/accessible.rs" , 30u32 , 1u32 ) )
                        }
                    };
                };
                Accessible(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiAccessible> for Accessible {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiAccessible) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/accessible.rs" , 30u32 , 1u32 ) )
                        }
                    };
                };
                Accessible(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiAccessible> for Accessible {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiAccessible) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiAccessible)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiAccessible,
                *mut *mut atspi_sys::AtspiAccessible,
            > for Accessible
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAccessible,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAccessible,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAccessible,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiAccessible,
                *mut *mut atspi_sys::AtspiAccessible,
            > for Accessible
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAccessible,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAccessible,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAccessible,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiAccessible,
                *const *mut atspi_sys::AtspiAccessible,
            > for Accessible
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiAccessible,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiAccessible,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/accessible.rs", 30u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiAccessible,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/accessible.rs", 30u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiAccessible,
                *const *mut atspi_sys::AtspiAccessible,
            > for Accessible
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiAccessible,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiAccessible,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/accessible.rs", 30u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(
                _: *const *mut atspi_sys::AtspiAccessible,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/accessible.rs", 30u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Accessible {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_accessible_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Accessible {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Accessible {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Accessible {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Accessible {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Accessible")
                    .field("inner", &self.0)
                    .field("type", &<Accessible as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Accessible {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Accessible>::from_glib_none(obj as *mut atspi_sys::AtspiAccessible)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Accessible {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiAccessible>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Accessible {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiAccessible>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        unsafe impl ::glib::object::IsA<Object> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Object> for Accessible {
            fn as_ref(&self) -> &Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        impl ::std::ops::Deref for AccessibleClass {
            type Target = <Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for AccessibleClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        unsafe impl ::glib::object::IsA<Action> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Action> for Accessible {
            fn as_ref(&self) -> &Action {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Collection> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Collection> for Accessible {
            fn as_ref(&self) -> &Collection {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Component> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Component> for Accessible {
            fn as_ref(&self) -> &Component {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Document> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Document> for Accessible {
            fn as_ref(&self) -> &Document {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<EditableText> for Accessible {}
        #[doc(hidden)]
        impl AsRef<EditableText> for Accessible {
            fn as_ref(&self) -> &EditableText {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Hypertext> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Hypertext> for Accessible {
            fn as_ref(&self) -> &Hypertext {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Image> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Image> for Accessible {
            fn as_ref(&self) -> &Image {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Selection> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Selection> for Accessible {
            fn as_ref(&self) -> &Selection {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Table> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Table> for Accessible {
            fn as_ref(&self) -> &Table {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<TableCell> for Accessible {}
        #[doc(hidden)]
        impl AsRef<TableCell> for Accessible {
            fn as_ref(&self) -> &TableCell {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Text> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Text> for Accessible {
            fn as_ref(&self) -> &Text {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        unsafe impl ::glib::object::IsA<Value> for Accessible {}
        #[doc(hidden)]
        impl AsRef<Value> for Accessible {
            fn as_ref(&self) -> &Value {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[repr(C)]
        pub struct AccessibleClass(atspi_sys::AtspiAccessibleClass);
        unsafe impl ::glib::object::IsClassFor for AccessibleClass {
            type Instance = Accessible;
        }
        unsafe impl Send for AccessibleClass {}
        unsafe impl Sync for AccessibleClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Accessible {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Accessible {}
        pub const NONE_ACCESSIBLE: Option<&Accessible> = None;
        pub trait AccessibleExt: 'static {
            fn clear_cache(&self);
            fn get_action_iface(&self) -> Option<Action>;
            fn get_application(&self) -> Result<Accessible, Error>;
            fn get_atspi_version(&self) -> Result<GString, Error>;
            fn get_child_at_index(&self, child_index: i32) -> Result<Accessible, Error>;
            fn get_child_count(&self) -> Result<i32, Error>;
            fn get_collection_iface(&self) -> Option<Collection>;
            fn get_component_iface(&self) -> Option<Component>;
            fn get_description(&self) -> Result<GString, Error>;
            fn get_document_iface(&self) -> Option<Document>;
            fn get_editable_text_iface(&self) -> Option<EditableText>;
            fn get_hyperlink(&self) -> Option<Hyperlink>;
            fn get_hypertext_iface(&self) -> Option<Hypertext>;
            fn get_id(&self) -> Result<i32, Error>;
            fn get_image_iface(&self) -> Option<Image>;
            fn get_index_in_parent(&self) -> Result<i32, Error>;
            fn get_localized_role_name(&self) -> Result<GString, Error>;
            fn get_name(&self) -> Result<GString, Error>;
            fn get_object_locale(&self) -> Result<GString, Error>;
            fn get_parent(&self) -> Result<Option<Accessible>, Error>;
            fn get_process_id(&self) -> Result<(), Error>;
            fn get_role(&self) -> Result<Role, Error>;
            fn get_role_name(&self) -> Result<GString, Error>;
            fn get_selection_iface(&self) -> Option<Selection>;
            fn get_state_set(&self) -> Option<StateSet>;
            fn get_table_cell(&self) -> Option<TableCell>;
            fn get_table_iface(&self) -> Option<Table>;
            fn get_text_iface(&self) -> Option<Text>;
            fn get_toolkit_name(&self) -> Result<GString, Error>;
            fn get_toolkit_version(&self) -> Result<GString, Error>;
            fn get_value_iface(&self) -> Option<Value>;
            fn set_cache_mask(&self, mask: Cache);
        }
        impl<O: IsA<Accessible>> AccessibleExt for O {
            fn clear_cache(&self) {
                unsafe {
                    atspi_sys::atspi_accessible_clear_cache(self.as_ref().to_glib_none().0);
                }
            }
            fn get_action_iface(&self) -> Option<Action> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_action_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_application(&self) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_application(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_atspi_version(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_atspi_version(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_child_at_index(&self, child_index: i32) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_child_at_index(
                        self.as_ref().to_glib_none().0,
                        child_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_child_count(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_child_count(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_collection_iface(&self) -> Option<Collection> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_collection_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_component_iface(&self) -> Option<Component> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_component_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_description(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_description(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_document_iface(&self) -> Option<Document> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_document_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_editable_text_iface(&self) -> Option<EditableText> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_editable_text_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_hyperlink(&self) -> Option<Hyperlink> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_hyperlink(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_hypertext_iface(&self) -> Option<Hypertext> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_hypertext_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_id(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_id(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_image_iface(&self) -> Option<Image> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_image_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_index_in_parent(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_index_in_parent(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_localized_role_name(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_localized_role_name(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_name(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_name(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_object_locale(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_object_locale(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_none(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_parent(&self) -> Result<Option<Accessible>, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_parent(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_process_id(&self) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_accessible_get_process_id(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_role(&self) -> Result<Role, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_role(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_role_name(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_role_name(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_selection_iface(&self) -> Option<Selection> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_selection_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_state_set(&self) -> Option<StateSet> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_state_set(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_table_cell(&self) -> Option<TableCell> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_table_cell(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_table_iface(&self) -> Option<Table> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_table_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_text_iface(&self) -> Option<Text> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_text_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_toolkit_name(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_toolkit_name(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_toolkit_version(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_accessible_get_toolkit_version(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_value_iface(&self) -> Option<Value> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_accessible_get_value_iface(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn set_cache_mask(&self, mask: Cache) {
                unsafe {
                    atspi_sys::atspi_accessible_set_cache_mask(
                        self.as_ref().to_glib_none().0,
                        mask.to_glib(),
                    );
                }
            }
        }
        impl fmt::Display for Accessible {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Accessible"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::accessible::AccessibleExt;
    pub use self::accessible::{Accessible, AccessibleClass, NONE_ACCESSIBLE};
    mod action {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::ptr;
        use Error;
        pub struct Action(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiAction>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Action {
            #[inline]
            fn clone(&self) -> Action {
                match *self {
                    Action(ref __self_0_0, ref __self_0_1) => Action(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Action {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Action(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Action {
            #[inline]
            fn cmp(&self, other: &Action) -> ::core::cmp::Ordering {
                match *other {
                    Action(ref __self_1_0, ref __self_1_1) => match *self {
                        Action(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Action {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Action {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Action(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Action {
            type GlibType = *mut atspi_sys::AtspiAction;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Action {
            type GlibType = atspi_sys::AtspiAction;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Action {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Action> for Action {
            fn as_ref(&self) -> &Action {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Action> for Action {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiAction> for Action {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiAction, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiAction {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiAction> for Action {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiAction, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiAction {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiAction>
            for Action
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiAction, Action>>,
                Option<Vec<*mut atspi_sys::AtspiAction>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Action],
            ) -> (*mut *mut atspi_sys::AtspiAction, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiAction);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiAction,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Action],
            ) -> (*mut *mut atspi_sys::AtspiAction, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiAction>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiAction;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Action]) -> *mut *mut atspi_sys::AtspiAction {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiAction>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiAction;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiAction>
            for Action
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiAction, Action>>,
                Option<Vec<*mut atspi_sys::AtspiAction>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Action],
            ) -> (*const *mut atspi_sys::AtspiAction, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiAction,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiAction, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Action],
            ) -> (*const *mut atspi_sys::AtspiAction, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/action.rs", 13u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Action]) -> *const *mut atspi_sys::AtspiAction {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/action.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiAction> for Action {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiAction) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/action.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Action(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiAction> for Action {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiAction) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/action.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Action(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiAction> for Action {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiAction) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/action.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Action(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiAction> for Action {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiAction) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/action.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Action(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiAction> for Action {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiAction) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiAction)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiAction,
                *mut *mut atspi_sys::AtspiAction,
            > for Action
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAction,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAction,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAction,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiAction,
                *mut *mut atspi_sys::AtspiAction,
            > for Action
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiAction) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiAction,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiAction) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiAction,
                *const *mut atspi_sys::AtspiAction,
            > for Action
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiAction,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiAction,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/action.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiAction,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/action.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiAction,
                *const *mut atspi_sys::AtspiAction,
            > for Action
        {
            unsafe fn from_glib_none_as_vec(ptr: *const *mut atspi_sys::AtspiAction) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiAction,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/action.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiAction) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/action.rs", 13u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Action {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_action_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Action {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Action {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Action {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Action {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Action")
                    .field("inner", &self.0)
                    .field("type", &<Action as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Action {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Action>::from_glib_none(obj as *mut atspi_sys::AtspiAction)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Action {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiAction>::to_glib_none(this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Action {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiAction>::to_glib_none(&this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Action {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Action {}
        pub const NONE_ACTION: Option<&Action> = None;
        pub trait ActionExt: 'static {
            fn do_action(&self, i: i32) -> Result<(), Error>;
            fn get_action_description(&self, i: i32) -> Result<GString, Error>;
            fn get_action_name(&self, i: i32) -> Result<GString, Error>;
            fn get_key_binding(&self, i: i32) -> Result<GString, Error>;
            fn get_localized_name(&self, i: i32) -> Result<GString, Error>;
            fn get_n_actions(&self) -> Result<i32, Error>;
        }
        impl<O: IsA<Action>> ActionExt for O {
            fn do_action(&self, i: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_action_do_action(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_action_description(&self, i: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_action_get_action_description(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_action_name(&self, i: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_action_get_action_name(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_key_binding(&self, i: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_action_get_key_binding(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_localized_name(&self, i: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_action_get_localized_name(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_actions(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_action_get_n_actions(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Action {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Action"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::action::ActionExt;
    pub use self::action::{Action, NONE_ACTION};
    mod collection {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use std::ptr;
        use Accessible;
        use Error;
        pub struct Collection(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiCollection>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Collection {
            #[inline]
            fn clone(&self) -> Collection {
                match *self {
                    Collection(ref __self_0_0, ref __self_0_1) => Collection(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Collection {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Collection(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Collection {
            #[inline]
            fn cmp(&self, other: &Collection) -> ::core::cmp::Ordering {
                match *other {
                    Collection(ref __self_1_0, ref __self_1_1) => match *self {
                        Collection(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Collection {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Collection {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Collection(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Collection {
            type GlibType = *mut atspi_sys::AtspiCollection;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Collection {
            type GlibType = atspi_sys::AtspiCollection;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Collection {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Collection> for Collection {
            fn as_ref(&self) -> &Collection {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Collection> for Collection {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiCollection> for Collection {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiCollection, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiCollection {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiCollection> for Collection {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiCollection, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiCollection {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiCollection>
            for Collection
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiCollection, Collection>>,
                Option<Vec<*mut atspi_sys::AtspiCollection>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Collection],
            ) -> (*mut *mut atspi_sys::AtspiCollection, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiCollection);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiCollection,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Collection],
            ) -> (*mut *mut atspi_sys::AtspiCollection, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiCollection>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiCollection;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Collection]) -> *mut *mut atspi_sys::AtspiCollection {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiCollection>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiCollection;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiCollection>
            for Collection
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiCollection, Collection>>,
                Option<Vec<*mut atspi_sys::AtspiCollection>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Collection],
            ) -> (*const *mut atspi_sys::AtspiCollection, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiCollection,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiCollection, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Collection],
            ) -> (*const *mut atspi_sys::AtspiCollection, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/collection.rs", 13u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Collection]) -> *const *mut atspi_sys::AtspiCollection {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/collection.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiCollection> for Collection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiCollection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/collection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Collection(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiCollection> for Collection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiCollection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/collection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Collection(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiCollection> for Collection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiCollection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/collection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Collection(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiCollection> for Collection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiCollection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/collection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Collection(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiCollection> for Collection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiCollection) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiCollection)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiCollection,
                *mut *mut atspi_sys::AtspiCollection,
            > for Collection
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiCollection,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiCollection,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiCollection,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiCollection,
                *mut *mut atspi_sys::AtspiCollection,
            > for Collection
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *mut *mut atspi_sys::AtspiCollection,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiCollection,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(
                ptr: *mut *mut atspi_sys::AtspiCollection,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiCollection,
                *const *mut atspi_sys::AtspiCollection,
            > for Collection
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiCollection,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiCollection,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/collection.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiCollection,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/collection.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiCollection,
                *const *mut atspi_sys::AtspiCollection,
            > for Collection
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiCollection,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiCollection,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/collection.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(
                _: *const *mut atspi_sys::AtspiCollection,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/collection.rs", 13u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Collection {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_collection_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Collection {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Collection {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Collection {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Collection {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Collection")
                    .field("inner", &self.0)
                    .field("type", &<Collection as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Collection {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Collection>::from_glib_none(obj as *mut atspi_sys::AtspiCollection)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Collection {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiCollection>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Collection {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiCollection>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Collection {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Collection {}
        pub const NONE_COLLECTION: Option<&Collection> = None;
        pub trait CollectionExt: 'static {
            fn get_active_descendant(&self) -> Result<Accessible, Error>;
            fn is_ancestor_of<P: IsA<Accessible>>(&self, test: &P) -> Result<(), Error>;
        }
        impl<O: IsA<Collection>> CollectionExt for O {
            fn get_active_descendant(&self) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_collection_get_active_descendant(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn is_ancestor_of<P: IsA<Accessible>>(&self, test: &P) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_collection_is_ancestor_of(
                        self.as_ref().to_glib_none().0,
                        test.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Collection {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Collection"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::collection::CollectionExt;
    pub use self::collection::{Collection, NONE_COLLECTION};
    mod component {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use libc;
        use std::fmt;
        use std::ptr;
        use Accessible;
        use ComponentLayer;
        use CoordType;
        use Error;
        use Point;
        use Rect;
        pub struct Component(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiComponent>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Component {
            #[inline]
            fn clone(&self) -> Component {
                match *self {
                    Component(ref __self_0_0, ref __self_0_1) => Component(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Component {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Component(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Component {
            #[inline]
            fn cmp(&self, other: &Component) -> ::core::cmp::Ordering {
                match *other {
                    Component(ref __self_1_0, ref __self_1_1) => match *self {
                        Component(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Component {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Component {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Component(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Component {
            type GlibType = *mut atspi_sys::AtspiComponent;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Component {
            type GlibType = atspi_sys::AtspiComponent;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Component {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Component> for Component {
            fn as_ref(&self) -> &Component {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Component> for Component {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiComponent> for Component {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiComponent, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiComponent {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiComponent> for Component {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiComponent, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiComponent {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiComponent>
            for Component
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiComponent, Component>>,
                Option<Vec<*mut atspi_sys::AtspiComponent>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Component],
            ) -> (*mut *mut atspi_sys::AtspiComponent, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiComponent);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiComponent,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Component],
            ) -> (*mut *mut atspi_sys::AtspiComponent, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiComponent>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiComponent;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Component]) -> *mut *mut atspi_sys::AtspiComponent {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiComponent>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiComponent;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiComponent>
            for Component
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiComponent, Component>>,
                Option<Vec<*mut atspi_sys::AtspiComponent>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Component],
            ) -> (*const *mut atspi_sys::AtspiComponent, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiComponent,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiComponent, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Component],
            ) -> (*const *mut atspi_sys::AtspiComponent, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/component.rs", 18u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Component]) -> *const *mut atspi_sys::AtspiComponent {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/component.rs", 18u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiComponent> for Component {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiComponent) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/component.rs" , 18u32 , 1u32 ) )
                        }
                    };
                };
                Component(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiComponent> for Component {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiComponent) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/component.rs" , 18u32 , 1u32 ) )
                        }
                    };
                };
                Component(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiComponent> for Component {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiComponent) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/component.rs" , 18u32 , 1u32 ) )
                        }
                    };
                };
                Component(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiComponent> for Component {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiComponent) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/component.rs" , 18u32 , 1u32 ) )
                        }
                    };
                };
                Component(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiComponent> for Component {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiComponent) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiComponent)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiComponent,
                *mut *mut atspi_sys::AtspiComponent,
            > for Component
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiComponent,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiComponent,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiComponent,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiComponent,
                *mut *mut atspi_sys::AtspiComponent,
            > for Component
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiComponent) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiComponent,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiComponent) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiComponent,
                *const *mut atspi_sys::AtspiComponent,
            > for Component
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiComponent,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiComponent,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/component.rs", 18u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiComponent,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/component.rs", 18u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiComponent,
                *const *mut atspi_sys::AtspiComponent,
            > for Component
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiComponent,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiComponent,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/component.rs", 18u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiComponent) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/component.rs", 18u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Component {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_component_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Component {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Component {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Component {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Component {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Component")
                    .field("inner", &self.0)
                    .field("type", &<Component as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Component {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Component>::from_glib_none(obj as *mut atspi_sys::AtspiComponent)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Component {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiComponent>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Component {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiComponent>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Component {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Component {}
        pub const NONE_COMPONENT: Option<&Component> = None;
        pub trait ComponentExt: 'static {
            fn contains(&self, x: i32, y: i32, ctype: CoordType) -> Result<(), Error>;
            fn get_accessible_at_point(
                &self,
                x: i32,
                y: i32,
                ctype: CoordType,
            ) -> Result<Option<Accessible>, Error>;
            fn get_alpha(&self) -> Result<f64, Error>;
            fn get_extents(&self, ctype: CoordType) -> Result<Rect, Error>;
            fn get_layer(&self) -> Result<ComponentLayer, Error>;
            fn get_mdi_z_order(&self) -> Result<libc::c_short, Error>;
            fn get_position(&self, ctype: CoordType) -> Result<Point, Error>;
            fn get_size(&self) -> Result<Point, Error>;
            fn grab_focus(&self) -> Result<(), Error>;
            fn set_extents(
                &self,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
                ctype: CoordType,
            ) -> Result<(), Error>;
            fn set_position(&self, x: i32, y: i32, ctype: CoordType) -> Result<(), Error>;
            fn set_size(&self, width: i32, height: i32) -> Result<(), Error>;
        }
        impl<O: IsA<Component>> ComponentExt for O {
            fn contains(&self, x: i32, y: i32, ctype: CoordType) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_component_contains(
                        self.as_ref().to_glib_none().0,
                        x,
                        y,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_accessible_at_point(
                &self,
                x: i32,
                y: i32,
                ctype: CoordType,
            ) -> Result<Option<Accessible>, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_accessible_at_point(
                        self.as_ref().to_glib_none().0,
                        x,
                        y,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_alpha(&self) -> Result<f64, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_alpha(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_extents(&self, ctype: CoordType) -> Result<Rect, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_extents(
                        self.as_ref().to_glib_none().0,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_layer(&self) -> Result<ComponentLayer, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_layer(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_mdi_z_order(&self) -> Result<libc::c_short, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_mdi_z_order(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_position(&self, ctype: CoordType) -> Result<Point, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_position(
                        self.as_ref().to_glib_none().0,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_size(&self) -> Result<Point, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_component_get_size(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn grab_focus(&self) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_component_grab_focus(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_extents(
                &self,
                x: i32,
                y: i32,
                width: i32,
                height: i32,
                ctype: CoordType,
            ) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_component_set_extents(
                        self.as_ref().to_glib_none().0,
                        x,
                        y,
                        width,
                        height,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_position(&self, x: i32, y: i32, ctype: CoordType) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_component_set_position(
                        self.as_ref().to_glib_none().0,
                        x,
                        y,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_size(&self, width: i32, height: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_component_set_size(
                        self.as_ref().to_glib_none().0,
                        width,
                        height,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Component {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Component"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::component::ComponentExt;
    pub use self::component::{Component, NONE_COMPONENT};
    mod device_listener {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        pub struct DeviceListener(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiDeviceListener>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DeviceListener {
            #[inline]
            fn clone(&self) -> DeviceListener {
                match *self {
                    DeviceListener(ref __self_0_0, ref __self_0_1) => DeviceListener(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for DeviceListener {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    DeviceListener(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for DeviceListener {
            #[inline]
            fn cmp(&self, other: &DeviceListener) -> ::core::cmp::Ordering {
                match *other {
                    DeviceListener(ref __self_1_0, ref __self_1_1) => match *self {
                        DeviceListener(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for DeviceListener {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for DeviceListener {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                DeviceListener(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for DeviceListener {
            type GlibType = *mut atspi_sys::AtspiDeviceListener;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for DeviceListener {
            type GlibType = atspi_sys::AtspiDeviceListener;
            type GlibClassType = atspi_sys::AtspiDeviceListenerClass;
            type RustClassType = DeviceListenerClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for DeviceListener {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<DeviceListener> for DeviceListener {
            fn as_ref(&self) -> &DeviceListener {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<DeviceListener> for DeviceListener {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiDeviceListener>
            for DeviceListener
        {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiDeviceListener, Self>
            {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiDeviceListener {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiDeviceListener> for DeviceListener {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiDeviceListener, Self>
            {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiDeviceListener {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<
                'a,
                *mut *mut atspi_sys::AtspiDeviceListener,
            > for DeviceListener
        {
            type Storage = (
                Vec<
                    ::glib::translate::Stash<
                        'a,
                        *mut atspi_sys::AtspiDeviceListener,
                        DeviceListener,
                    >,
                >,
                Option<Vec<*mut atspi_sys::AtspiDeviceListener>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [DeviceListener],
            ) -> (*mut *mut atspi_sys::AtspiDeviceListener, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiDeviceListener);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiDeviceListener,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [DeviceListener],
            ) -> (*mut *mut atspi_sys::AtspiDeviceListener, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiDeviceListener>()
                            * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiDeviceListener;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(
                t: &[DeviceListener],
            ) -> *mut *mut atspi_sys::AtspiDeviceListener {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiDeviceListener>()
                            * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiDeviceListener;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<
                'a,
                *const *mut atspi_sys::AtspiDeviceListener,
            > for DeviceListener
        {
            type Storage = (
                Vec<
                    ::glib::translate::Stash<
                        'a,
                        *mut atspi_sys::AtspiDeviceListener,
                        DeviceListener,
                    >,
                >,
                Option<Vec<*mut atspi_sys::AtspiDeviceListener>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [DeviceListener],
            ) -> (*const *mut atspi_sys::AtspiDeviceListener, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiDeviceListener,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiDeviceListener, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [DeviceListener],
            ) -> (*const *mut atspi_sys::AtspiDeviceListener, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_listener.rs", 10u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(
                _: &[DeviceListener],
            ) -> *const *mut atspi_sys::AtspiDeviceListener {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_listener.rs", 10u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiDeviceListener> for DeviceListener {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiDeviceListener) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/device_listener.rs" , 10u32 , 1u32 ) )
                        }
                    };
                };
                DeviceListener(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiDeviceListener> for DeviceListener {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiDeviceListener) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/device_listener.rs" , 10u32 , 1u32 ) )
                        }
                    };
                };
                DeviceListener(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiDeviceListener> for DeviceListener {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiDeviceListener) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/device_listener.rs" , 10u32 , 1u32 ) )
                        }
                    };
                };
                DeviceListener(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiDeviceListener> for DeviceListener {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiDeviceListener) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/device_listener.rs" , 10u32 , 1u32 ) )
                        }
                    };
                };
                DeviceListener(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiDeviceListener>
            for DeviceListener
        {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiDeviceListener) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiDeviceListener)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiDeviceListener,
                *mut *mut atspi_sys::AtspiDeviceListener,
            > for DeviceListener
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceListener,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceListener,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceListener,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiDeviceListener,
                *mut *mut atspi_sys::AtspiDeviceListener,
            > for DeviceListener
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceListener,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceListener,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceListener,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiDeviceListener,
                *const *mut atspi_sys::AtspiDeviceListener,
            > for DeviceListener
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiDeviceListener,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiDeviceListener,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_listener.rs", 10u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiDeviceListener,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_listener.rs", 10u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiDeviceListener,
                *const *mut atspi_sys::AtspiDeviceListener,
            > for DeviceListener
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiDeviceListener,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiDeviceListener,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_listener.rs", 10u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(
                _: *const *mut atspi_sys::AtspiDeviceListener,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_listener.rs", 10u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for DeviceListener {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_device_listener_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for DeviceListener {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for DeviceListener {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for DeviceListener {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for DeviceListener {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("DeviceListener")
                    .field("inner", &self.0)
                    .field(
                        "type",
                        &<DeviceListener as ::glib::ObjectExt>::get_type(self),
                    )
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for DeviceListener {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<DeviceListener>::from_glib_none(obj as *mut atspi_sys::AtspiDeviceListener)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for DeviceListener {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                :: glib :: gobject_sys :: g_value_set_object ( :: glib :: translate :: ToGlibPtrMut :: to_glib_none_mut ( value ) . 0 , :: glib :: translate :: ToGlibPtr :: < * mut atspi_sys :: AtspiDeviceListener > :: to_glib_none ( this ) . 0 as * mut :: glib :: gobject_sys :: GObject )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for DeviceListener {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                :: glib :: gobject_sys :: g_value_set_object ( :: glib :: translate :: ToGlibPtrMut :: to_glib_none_mut ( value ) . 0 , :: glib :: translate :: ToGlibPtr :: < * mut atspi_sys :: AtspiDeviceListener > :: to_glib_none ( & this ) . 0 as * mut :: glib :: gobject_sys :: GObject )
            }
        }
        impl ::std::ops::Deref for DeviceListenerClass {
            type Target = <::glib::object::Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for DeviceListenerClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        #[repr(C)]
        pub struct DeviceListenerClass(atspi_sys::AtspiDeviceListenerClass);
        unsafe impl ::glib::object::IsClassFor for DeviceListenerClass {
            type Instance = DeviceListener;
        }
        unsafe impl Send for DeviceListenerClass {}
        unsafe impl Sync for DeviceListenerClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for DeviceListener {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for DeviceListener {}
        impl DeviceListener {}
        pub const NONE_DEVICE_LISTENER: Option<&DeviceListener> = None;
        pub trait DeviceListenerExt: 'static {}
        impl<O: IsA<DeviceListener>> DeviceListenerExt for O {}
        impl fmt::Display for DeviceListener {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["DeviceListener"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::device_listener::DeviceListenerExt;
    pub use self::device_listener::{DeviceListener, DeviceListenerClass, NONE_DEVICE_LISTENER};
    mod document {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::ptr;
        use Error;
        pub struct Document(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiDocument>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Document {
            #[inline]
            fn clone(&self) -> Document {
                match *self {
                    Document(ref __self_0_0, ref __self_0_1) => Document(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Document {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Document(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Document {
            #[inline]
            fn cmp(&self, other: &Document) -> ::core::cmp::Ordering {
                match *other {
                    Document(ref __self_1_0, ref __self_1_1) => match *self {
                        Document(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Document {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Document {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Document(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Document {
            type GlibType = *mut atspi_sys::AtspiDocument;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Document {
            type GlibType = atspi_sys::AtspiDocument;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Document {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Document> for Document {
            fn as_ref(&self) -> &Document {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Document> for Document {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiDocument> for Document {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiDocument, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiDocument {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiDocument> for Document {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiDocument, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiDocument {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiDocument>
            for Document
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiDocument, Document>>,
                Option<Vec<*mut atspi_sys::AtspiDocument>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Document],
            ) -> (*mut *mut atspi_sys::AtspiDocument, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiDocument);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiDocument,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Document],
            ) -> (*mut *mut atspi_sys::AtspiDocument, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiDocument>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiDocument;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Document]) -> *mut *mut atspi_sys::AtspiDocument {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiDocument>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiDocument;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiDocument>
            for Document
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiDocument, Document>>,
                Option<Vec<*mut atspi_sys::AtspiDocument>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Document],
            ) -> (*const *mut atspi_sys::AtspiDocument, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiDocument,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiDocument, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Document],
            ) -> (*const *mut atspi_sys::AtspiDocument, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/document.rs", 13u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Document]) -> *const *mut atspi_sys::AtspiDocument {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/document.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiDocument> for Document {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiDocument) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/document.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Document(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiDocument> for Document {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiDocument) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/document.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Document(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiDocument> for Document {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiDocument) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/document.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Document(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiDocument> for Document {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiDocument) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/document.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Document(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiDocument> for Document {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiDocument) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiDocument)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiDocument,
                *mut *mut atspi_sys::AtspiDocument,
            > for Document
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDocument,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDocument,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDocument,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiDocument,
                *mut *mut atspi_sys::AtspiDocument,
            > for Document
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiDocument) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDocument,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiDocument) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiDocument,
                *const *mut atspi_sys::AtspiDocument,
            > for Document
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiDocument,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiDocument,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/document.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiDocument,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/document.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiDocument,
                *const *mut atspi_sys::AtspiDocument,
            > for Document
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiDocument,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiDocument,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/document.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiDocument) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/document.rs", 13u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Document {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_document_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Document {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Document {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Document {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Document {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Document")
                    .field("inner", &self.0)
                    .field("type", &<Document as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Document {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Document>::from_glib_none(obj as *mut atspi_sys::AtspiDocument)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Document {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiDocument>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Document {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiDocument>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Document {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Document {}
        pub const NONE_DOCUMENT: Option<&Document> = None;
        pub trait DocumentExt: 'static {
            fn get_current_page_number(&self) -> Result<i32, Error>;
            fn get_document_attribute_value(&self, attribute: &str) -> Result<GString, Error>;
            fn get_locale(&self) -> Result<GString, Error>;
            fn get_page_count(&self) -> Result<i32, Error>;
        }
        impl<O: IsA<Document>> DocumentExt for O {
            fn get_current_page_number(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_document_get_current_page_number(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_document_attribute_value(&self, attribute: &str) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_document_get_document_attribute_value(
                        self.as_ref().to_glib_none().0,
                        attribute.to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_locale(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_document_get_locale(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_page_count(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_document_get_page_count(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Document {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Document"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::document::DocumentExt;
    pub use self::document::{Document, NONE_DOCUMENT};
    mod editable_text {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use std::ptr;
        use Error;
        pub struct EditableText(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiEditableText>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for EditableText {
            #[inline]
            fn clone(&self) -> EditableText {
                match *self {
                    EditableText(ref __self_0_0, ref __self_0_1) => EditableText(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for EditableText {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    EditableText(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for EditableText {
            #[inline]
            fn cmp(&self, other: &EditableText) -> ::core::cmp::Ordering {
                match *other {
                    EditableText(ref __self_1_0, ref __self_1_1) => match *self {
                        EditableText(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for EditableText {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for EditableText {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                EditableText(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for EditableText {
            type GlibType = *mut atspi_sys::AtspiEditableText;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for EditableText {
            type GlibType = atspi_sys::AtspiEditableText;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for EditableText {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<EditableText> for EditableText {
            fn as_ref(&self) -> &EditableText {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<EditableText> for EditableText {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiEditableText> for EditableText {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiEditableText, Self>
            {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiEditableText {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiEditableText> for EditableText {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiEditableText, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiEditableText {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiEditableText>
            for EditableText
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiEditableText, EditableText>>,
                Option<Vec<*mut atspi_sys::AtspiEditableText>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [EditableText],
            ) -> (*mut *mut atspi_sys::AtspiEditableText, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiEditableText);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiEditableText,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [EditableText],
            ) -> (*mut *mut atspi_sys::AtspiEditableText, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiEditableText>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiEditableText;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(
                t: &[EditableText],
            ) -> *mut *mut atspi_sys::AtspiEditableText {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiEditableText>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiEditableText;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<
                'a,
                *const *mut atspi_sys::AtspiEditableText,
            > for EditableText
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiEditableText, EditableText>>,
                Option<Vec<*mut atspi_sys::AtspiEditableText>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [EditableText],
            ) -> (*const *mut atspi_sys::AtspiEditableText, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiEditableText,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiEditableText, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [EditableText],
            ) -> (*const *mut atspi_sys::AtspiEditableText, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/editable_text.rs", 12u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(
                _: &[EditableText],
            ) -> *const *mut atspi_sys::AtspiEditableText {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/editable_text.rs", 12u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiEditableText> for EditableText {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiEditableText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/editable_text.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                EditableText(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiEditableText> for EditableText {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiEditableText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/editable_text.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                EditableText(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiEditableText> for EditableText {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiEditableText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/editable_text.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                EditableText(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiEditableText> for EditableText {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiEditableText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/editable_text.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                EditableText(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiEditableText> for EditableText {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiEditableText) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiEditableText)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiEditableText,
                *mut *mut atspi_sys::AtspiEditableText,
            > for EditableText
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEditableText,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEditableText,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEditableText,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiEditableText,
                *mut *mut atspi_sys::AtspiEditableText,
            > for EditableText
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEditableText,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEditableText,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEditableText,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiEditableText,
                *const *mut atspi_sys::AtspiEditableText,
            > for EditableText
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiEditableText,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiEditableText,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/editable_text.rs", 12u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiEditableText,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/editable_text.rs", 12u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiEditableText,
                *const *mut atspi_sys::AtspiEditableText,
            > for EditableText
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiEditableText,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiEditableText,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/editable_text.rs", 12u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(
                _: *const *mut atspi_sys::AtspiEditableText,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/editable_text.rs", 12u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for EditableText {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_editable_text_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for EditableText {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for EditableText {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for EditableText {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for EditableText {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("EditableText")
                    .field("inner", &self.0)
                    .field("type", &<EditableText as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for EditableText {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<EditableText>::from_glib_none(obj as *mut atspi_sys::AtspiEditableText)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for EditableText {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiEditableText>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for EditableText {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiEditableText>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for EditableText {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for EditableText {}
        pub const NONE_EDITABLE_TEXT: Option<&EditableText> = None;
        pub trait EditableTextExt: 'static {
            fn copy_text(&self, start_pos: i32, end_pos: i32) -> Result<(), Error>;
            fn cut_text(&self, start_pos: i32, end_pos: i32) -> Result<(), Error>;
            fn delete_text(&self, start_pos: i32, end_pos: i32) -> Result<(), Error>;
            fn insert_text(&self, position: i32, text: &str) -> Result<(), Error>;
            fn paste_text(&self, position: i32) -> Result<(), Error>;
            fn set_text_contents(&self, new_contents: &str) -> Result<(), Error>;
        }
        impl<O: IsA<EditableText>> EditableTextExt for O {
            fn copy_text(&self, start_pos: i32, end_pos: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_editable_text_copy_text(
                        self.as_ref().to_glib_none().0,
                        start_pos,
                        end_pos,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn cut_text(&self, start_pos: i32, end_pos: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_editable_text_cut_text(
                        self.as_ref().to_glib_none().0,
                        start_pos,
                        end_pos,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn delete_text(&self, start_pos: i32, end_pos: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_editable_text_delete_text(
                        self.as_ref().to_glib_none().0,
                        start_pos,
                        end_pos,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn insert_text(&self, position: i32, text: &str) -> Result<(), Error> {
                let length = text.len() as i32;
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_editable_text_insert_text(
                        self.as_ref().to_glib_none().0,
                        position,
                        text.to_glib_none().0,
                        length,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn paste_text(&self, position: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_editable_text_paste_text(
                        self.as_ref().to_glib_none().0,
                        position,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_text_contents(&self, new_contents: &str) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_editable_text_set_text_contents(
                        self.as_ref().to_glib_none().0,
                        new_contents.to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for EditableText {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["EditableText"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::editable_text::EditableTextExt;
    pub use self::editable_text::{EditableText, NONE_EDITABLE_TEXT};
    mod hyperlink {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::ptr;
        use Accessible;
        use Error;
        use Object;
        use Range;
        pub struct Hyperlink(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiHyperlink>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Hyperlink {
            #[inline]
            fn clone(&self) -> Hyperlink {
                match *self {
                    Hyperlink(ref __self_0_0, ref __self_0_1) => Hyperlink(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Hyperlink {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Hyperlink(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Hyperlink {
            #[inline]
            fn cmp(&self, other: &Hyperlink) -> ::core::cmp::Ordering {
                match *other {
                    Hyperlink(ref __self_1_0, ref __self_1_1) => match *self {
                        Hyperlink(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Hyperlink {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Hyperlink {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Hyperlink(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Hyperlink {
            type GlibType = *mut atspi_sys::AtspiHyperlink;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Hyperlink {
            type GlibType = atspi_sys::AtspiHyperlink;
            type GlibClassType = atspi_sys::AtspiHyperlinkClass;
            type RustClassType = HyperlinkClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Hyperlink {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Hyperlink> for Hyperlink {
            fn as_ref(&self) -> &Hyperlink {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Hyperlink> for Hyperlink {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiHyperlink> for Hyperlink {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiHyperlink, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiHyperlink {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiHyperlink> for Hyperlink {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiHyperlink, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiHyperlink {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiHyperlink>
            for Hyperlink
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiHyperlink, Hyperlink>>,
                Option<Vec<*mut atspi_sys::AtspiHyperlink>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Hyperlink],
            ) -> (*mut *mut atspi_sys::AtspiHyperlink, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiHyperlink);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiHyperlink,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Hyperlink],
            ) -> (*mut *mut atspi_sys::AtspiHyperlink, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiHyperlink>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiHyperlink;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Hyperlink]) -> *mut *mut atspi_sys::AtspiHyperlink {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiHyperlink>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiHyperlink;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiHyperlink>
            for Hyperlink
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiHyperlink, Hyperlink>>,
                Option<Vec<*mut atspi_sys::AtspiHyperlink>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Hyperlink],
            ) -> (*const *mut atspi_sys::AtspiHyperlink, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiHyperlink,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiHyperlink, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Hyperlink],
            ) -> (*const *mut atspi_sys::AtspiHyperlink, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hyperlink.rs", 16u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Hyperlink]) -> *const *mut atspi_sys::AtspiHyperlink {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hyperlink.rs", 16u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiHyperlink> for Hyperlink {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiHyperlink) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hyperlink.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Hyperlink(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiHyperlink> for Hyperlink {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiHyperlink) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hyperlink.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Hyperlink(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiHyperlink> for Hyperlink {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiHyperlink) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hyperlink.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Hyperlink(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiHyperlink> for Hyperlink {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiHyperlink) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hyperlink.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Hyperlink(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiHyperlink> for Hyperlink {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiHyperlink) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiHyperlink)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiHyperlink,
                *mut *mut atspi_sys::AtspiHyperlink,
            > for Hyperlink
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHyperlink,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHyperlink,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHyperlink,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiHyperlink,
                *mut *mut atspi_sys::AtspiHyperlink,
            > for Hyperlink
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiHyperlink) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHyperlink,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiHyperlink) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiHyperlink,
                *const *mut atspi_sys::AtspiHyperlink,
            > for Hyperlink
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiHyperlink,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiHyperlink,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hyperlink.rs", 16u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiHyperlink,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hyperlink.rs", 16u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiHyperlink,
                *const *mut atspi_sys::AtspiHyperlink,
            > for Hyperlink
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiHyperlink,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiHyperlink,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hyperlink.rs", 16u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiHyperlink) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hyperlink.rs", 16u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Hyperlink {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_hyperlink_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Hyperlink {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Hyperlink {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Hyperlink {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Hyperlink {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Hyperlink")
                    .field("inner", &self.0)
                    .field("type", &<Hyperlink as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Hyperlink {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Hyperlink>::from_glib_none(obj as *mut atspi_sys::AtspiHyperlink)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Hyperlink {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiHyperlink>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Hyperlink {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiHyperlink>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        unsafe impl ::glib::object::IsA<Object> for Hyperlink {}
        #[doc(hidden)]
        impl AsRef<Object> for Hyperlink {
            fn as_ref(&self) -> &Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        impl ::std::ops::Deref for HyperlinkClass {
            type Target = <Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for HyperlinkClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        #[repr(C)]
        pub struct HyperlinkClass(atspi_sys::AtspiHyperlinkClass);
        unsafe impl ::glib::object::IsClassFor for HyperlinkClass {
            type Instance = Hyperlink;
        }
        unsafe impl Send for HyperlinkClass {}
        unsafe impl Sync for HyperlinkClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Hyperlink {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Hyperlink {}
        pub const NONE_HYPERLINK: Option<&Hyperlink> = None;
        pub trait HyperlinkExt: 'static {
            fn get_end_index(&self) -> Result<i32, Error>;
            fn get_index_range(&self) -> Result<Range, Error>;
            fn get_n_anchors(&self) -> Result<i32, Error>;
            fn get_object(&self, i: i32) -> Result<Accessible, Error>;
            fn get_start_index(&self) -> Result<i32, Error>;
            fn get_uri(&self, i: i32) -> Result<GString, Error>;
            fn is_valid(&self) -> Result<(), Error>;
        }
        impl<O: IsA<Hyperlink>> HyperlinkExt for O {
            fn get_end_index(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hyperlink_get_end_index(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_index_range(&self) -> Result<Range, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hyperlink_get_index_range(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_anchors(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hyperlink_get_n_anchors(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_object(&self, i: i32) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hyperlink_get_object(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_start_index(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hyperlink_get_start_index(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_uri(&self, i: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hyperlink_get_uri(
                        self.as_ref().to_glib_none().0,
                        i,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn is_valid(&self) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_hyperlink_is_valid(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Hyperlink {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Hyperlink"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::hyperlink::HyperlinkExt;
    pub use self::hyperlink::{Hyperlink, HyperlinkClass, NONE_HYPERLINK};
    mod hypertext {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use std::ptr;
        use Error;
        use Hyperlink;
        pub struct Hypertext(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiHypertext>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Hypertext {
            #[inline]
            fn clone(&self) -> Hypertext {
                match *self {
                    Hypertext(ref __self_0_0, ref __self_0_1) => Hypertext(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Hypertext {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Hypertext(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Hypertext {
            #[inline]
            fn cmp(&self, other: &Hypertext) -> ::core::cmp::Ordering {
                match *other {
                    Hypertext(ref __self_1_0, ref __self_1_1) => match *self {
                        Hypertext(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Hypertext {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Hypertext {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Hypertext(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Hypertext {
            type GlibType = *mut atspi_sys::AtspiHypertext;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Hypertext {
            type GlibType = atspi_sys::AtspiHypertext;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Hypertext {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Hypertext> for Hypertext {
            fn as_ref(&self) -> &Hypertext {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Hypertext> for Hypertext {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiHypertext> for Hypertext {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiHypertext, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiHypertext {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiHypertext> for Hypertext {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiHypertext, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiHypertext {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiHypertext>
            for Hypertext
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiHypertext, Hypertext>>,
                Option<Vec<*mut atspi_sys::AtspiHypertext>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Hypertext],
            ) -> (*mut *mut atspi_sys::AtspiHypertext, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiHypertext);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiHypertext,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Hypertext],
            ) -> (*mut *mut atspi_sys::AtspiHypertext, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiHypertext>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiHypertext;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Hypertext]) -> *mut *mut atspi_sys::AtspiHypertext {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiHypertext>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiHypertext;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiHypertext>
            for Hypertext
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiHypertext, Hypertext>>,
                Option<Vec<*mut atspi_sys::AtspiHypertext>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Hypertext],
            ) -> (*const *mut atspi_sys::AtspiHypertext, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiHypertext,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiHypertext, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Hypertext],
            ) -> (*const *mut atspi_sys::AtspiHypertext, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hypertext.rs", 13u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Hypertext]) -> *const *mut atspi_sys::AtspiHypertext {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hypertext.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiHypertext> for Hypertext {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiHypertext) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hypertext.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Hypertext(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiHypertext> for Hypertext {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiHypertext) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hypertext.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Hypertext(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiHypertext> for Hypertext {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiHypertext) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hypertext.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Hypertext(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiHypertext> for Hypertext {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiHypertext) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/hypertext.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Hypertext(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiHypertext> for Hypertext {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiHypertext) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiHypertext)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiHypertext,
                *mut *mut atspi_sys::AtspiHypertext,
            > for Hypertext
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHypertext,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHypertext,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHypertext,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiHypertext,
                *mut *mut atspi_sys::AtspiHypertext,
            > for Hypertext
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiHypertext) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiHypertext,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiHypertext) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiHypertext,
                *const *mut atspi_sys::AtspiHypertext,
            > for Hypertext
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiHypertext,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiHypertext,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hypertext.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiHypertext,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hypertext.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiHypertext,
                *const *mut atspi_sys::AtspiHypertext,
            > for Hypertext
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiHypertext,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiHypertext,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hypertext.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiHypertext) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/hypertext.rs", 13u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Hypertext {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_hypertext_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Hypertext {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Hypertext {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Hypertext {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Hypertext {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Hypertext")
                    .field("inner", &self.0)
                    .field("type", &<Hypertext as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Hypertext {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Hypertext>::from_glib_none(obj as *mut atspi_sys::AtspiHypertext)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Hypertext {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiHypertext>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Hypertext {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiHypertext>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Hypertext {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Hypertext {}
        pub const NONE_HYPERTEXT: Option<&Hypertext> = None;
        pub trait HypertextExt: 'static {
            fn get_link(&self, link_index: i32) -> Result<Option<Hyperlink>, Error>;
            fn get_link_index(&self, character_offset: i32) -> Result<i32, Error>;
            fn get_n_links(&self) -> Result<i32, Error>;
        }
        impl<O: IsA<Hypertext>> HypertextExt for O {
            fn get_link(&self, link_index: i32) -> Result<Option<Hyperlink>, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hypertext_get_link(
                        self.as_ref().to_glib_none().0,
                        link_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_link_index(&self, character_offset: i32) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hypertext_get_link_index(
                        self.as_ref().to_glib_none().0,
                        character_offset,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_links(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_hypertext_get_n_links(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Hypertext {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Hypertext"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::hypertext::HypertextExt;
    pub use self::hypertext::{Hypertext, NONE_HYPERTEXT};
    mod image {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::ptr;
        use CoordType;
        use Error;
        use Point;
        use Rect;
        pub struct Image(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiImage>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Image {
            #[inline]
            fn clone(&self) -> Image {
                match *self {
                    Image(ref __self_0_0, ref __self_0_1) => Image(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Image {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Image(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Image {
            #[inline]
            fn cmp(&self, other: &Image) -> ::core::cmp::Ordering {
                match *other {
                    Image(ref __self_1_0, ref __self_1_1) => match *self {
                        Image(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Image {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Image {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Image(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Image {
            type GlibType = *mut atspi_sys::AtspiImage;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Image {
            type GlibType = atspi_sys::AtspiImage;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Image {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Image> for Image {
            fn as_ref(&self) -> &Image {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Image> for Image {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiImage> for Image {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiImage, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiImage {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiImage> for Image {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiImage, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiImage {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiImage>
            for Image
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiImage, Image>>,
                Option<Vec<*mut atspi_sys::AtspiImage>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Image],
            ) -> (*mut *mut atspi_sys::AtspiImage, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiImage);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiImage,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Image],
            ) -> (*mut *mut atspi_sys::AtspiImage, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiImage>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiImage;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Image]) -> *mut *mut atspi_sys::AtspiImage {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiImage>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiImage;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiImage>
            for Image
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiImage, Image>>,
                Option<Vec<*mut atspi_sys::AtspiImage>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Image],
            ) -> (*const *mut atspi_sys::AtspiImage, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiImage,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiImage, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Image],
            ) -> (*const *mut atspi_sys::AtspiImage, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/image.rs", 16u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Image]) -> *const *mut atspi_sys::AtspiImage {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/image.rs", 16u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiImage> for Image {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiImage) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/image.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Image(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiImage> for Image {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiImage) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/image.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Image(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiImage> for Image {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiImage) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/image.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Image(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiImage> for Image {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiImage) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/image.rs" , 16u32 , 1u32 ) )
                        }
                    };
                };
                Image(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiImage> for Image {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiImage) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiImage)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiImage,
                *mut *mut atspi_sys::AtspiImage,
            > for Image
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiImage,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiImage,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiImage,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiImage,
                *mut *mut atspi_sys::AtspiImage,
            > for Image
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiImage) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiImage,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiImage) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiImage,
                *const *mut atspi_sys::AtspiImage,
            > for Image
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiImage,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiImage,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/image.rs", 16u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiImage,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/image.rs", 16u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiImage,
                *const *mut atspi_sys::AtspiImage,
            > for Image
        {
            unsafe fn from_glib_none_as_vec(ptr: *const *mut atspi_sys::AtspiImage) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiImage,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/image.rs", 16u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiImage) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/image.rs", 16u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Image {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_image_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Image {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Image {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Image {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Image {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Image")
                    .field("inner", &self.0)
                    .field("type", &<Image as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Image {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Image>::from_glib_none(obj as *mut atspi_sys::AtspiImage)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Image {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiImage>::to_glib_none(this).0
                        as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Image {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiImage>::to_glib_none(&this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Image {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Image {}
        pub const NONE_IMAGE: Option<&Image> = None;
        pub trait ImageExt: 'static {
            fn get_image_description(&self) -> Result<GString, Error>;
            fn get_image_extents(&self, ctype: CoordType) -> Result<Rect, Error>;
            fn get_image_locale(&self) -> Result<GString, Error>;
            fn get_image_position(&self, ctype: CoordType) -> Result<Point, Error>;
            fn get_image_size(&self) -> Result<Point, Error>;
        }
        impl<O: IsA<Image>> ImageExt for O {
            fn get_image_description(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_image_get_image_description(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_image_extents(&self, ctype: CoordType) -> Result<Rect, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_image_get_image_extents(
                        self.as_ref().to_glib_none().0,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_image_locale(&self) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_image_get_image_locale(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_image_position(&self, ctype: CoordType) -> Result<Point, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_image_get_image_position(
                        self.as_ref().to_glib_none().0,
                        ctype.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_image_size(&self) -> Result<Point, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_image_get_image_size(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Image {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Image"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::image::ImageExt;
    pub use self::image::{Image, NONE_IMAGE};
    mod match_rule {
        use atspi_sys;
        use glib::translate::*;
        use std::fmt;
        pub struct MatchRule(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiMatchRule>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for MatchRule {
            #[inline]
            fn clone(&self) -> MatchRule {
                match *self {
                    MatchRule(ref __self_0_0, ref __self_0_1) => MatchRule(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for MatchRule {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    MatchRule(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for MatchRule {
            #[inline]
            fn cmp(&self, other: &MatchRule) -> ::core::cmp::Ordering {
                match *other {
                    MatchRule(ref __self_1_0, ref __self_1_1) => match *self {
                        MatchRule(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for MatchRule {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for MatchRule {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                MatchRule(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for MatchRule {
            type GlibType = *mut atspi_sys::AtspiMatchRule;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for MatchRule {
            type GlibType = atspi_sys::AtspiMatchRule;
            type GlibClassType = atspi_sys::AtspiMatchRuleClass;
            type RustClassType = MatchRuleClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for MatchRule {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<MatchRule> for MatchRule {
            fn as_ref(&self) -> &MatchRule {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<MatchRule> for MatchRule {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiMatchRule> for MatchRule {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiMatchRule, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiMatchRule {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiMatchRule> for MatchRule {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiMatchRule, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiMatchRule {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiMatchRule>
            for MatchRule
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiMatchRule, MatchRule>>,
                Option<Vec<*mut atspi_sys::AtspiMatchRule>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [MatchRule],
            ) -> (*mut *mut atspi_sys::AtspiMatchRule, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiMatchRule);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiMatchRule,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [MatchRule],
            ) -> (*mut *mut atspi_sys::AtspiMatchRule, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiMatchRule>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiMatchRule;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[MatchRule]) -> *mut *mut atspi_sys::AtspiMatchRule {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiMatchRule>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiMatchRule;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiMatchRule>
            for MatchRule
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiMatchRule, MatchRule>>,
                Option<Vec<*mut atspi_sys::AtspiMatchRule>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [MatchRule],
            ) -> (*const *mut atspi_sys::AtspiMatchRule, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiMatchRule,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiMatchRule, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [MatchRule],
            ) -> (*const *mut atspi_sys::AtspiMatchRule, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/match_rule.rs", 9u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[MatchRule]) -> *const *mut atspi_sys::AtspiMatchRule {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/match_rule.rs", 9u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiMatchRule> for MatchRule {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiMatchRule) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/match_rule.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                MatchRule(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiMatchRule> for MatchRule {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiMatchRule) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/match_rule.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                MatchRule(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiMatchRule> for MatchRule {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiMatchRule) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/match_rule.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                MatchRule(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiMatchRule> for MatchRule {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiMatchRule) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/match_rule.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                MatchRule(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiMatchRule> for MatchRule {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiMatchRule) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiMatchRule)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiMatchRule,
                *mut *mut atspi_sys::AtspiMatchRule,
            > for MatchRule
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiMatchRule,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiMatchRule,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiMatchRule,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiMatchRule,
                *mut *mut atspi_sys::AtspiMatchRule,
            > for MatchRule
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiMatchRule) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiMatchRule,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiMatchRule) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiMatchRule,
                *const *mut atspi_sys::AtspiMatchRule,
            > for MatchRule
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiMatchRule,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiMatchRule,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/match_rule.rs", 9u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiMatchRule,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/match_rule.rs", 9u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiMatchRule,
                *const *mut atspi_sys::AtspiMatchRule,
            > for MatchRule
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiMatchRule,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiMatchRule,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/match_rule.rs", 9u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiMatchRule) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/match_rule.rs", 9u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for MatchRule {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_match_rule_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for MatchRule {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for MatchRule {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for MatchRule {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for MatchRule {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("MatchRule")
                    .field("inner", &self.0)
                    .field("type", &<MatchRule as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for MatchRule {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<MatchRule>::from_glib_none(obj as *mut atspi_sys::AtspiMatchRule)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for MatchRule {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiMatchRule>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for MatchRule {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiMatchRule>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        impl ::std::ops::Deref for MatchRuleClass {
            type Target = <::glib::object::Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for MatchRuleClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        #[repr(C)]
        pub struct MatchRuleClass(atspi_sys::AtspiMatchRuleClass);
        unsafe impl ::glib::object::IsClassFor for MatchRuleClass {
            type Instance = MatchRule;
        }
        unsafe impl Send for MatchRuleClass {}
        unsafe impl Sync for MatchRuleClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for MatchRule {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for MatchRule {}
        impl MatchRule {}
        pub const NONE_MATCH_RULE: Option<&MatchRule> = None;
        impl fmt::Display for MatchRule {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["MatchRule"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::match_rule::{MatchRule, MatchRuleClass, NONE_MATCH_RULE};
    mod object {
        use atspi_sys;
        use glib::translate::*;
        use std::fmt;
        pub struct Object(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiObject>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Object {
            #[inline]
            fn clone(&self) -> Object {
                match *self {
                    Object(ref __self_0_0, ref __self_0_1) => Object(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Object {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Object(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Object {
            #[inline]
            fn cmp(&self, other: &Object) -> ::core::cmp::Ordering {
                match *other {
                    Object(ref __self_1_0, ref __self_1_1) => match *self {
                        Object(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Object {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Object {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Object(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Object {
            type GlibType = *mut atspi_sys::AtspiObject;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Object {
            type GlibType = atspi_sys::AtspiObject;
            type GlibClassType = atspi_sys::AtspiObjectClass;
            type RustClassType = ObjectClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Object {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Object> for Object {
            fn as_ref(&self) -> &Object {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Object> for Object {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiObject> for Object {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiObject, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiObject {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiObject> for Object {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiObject, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiObject {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiObject>
            for Object
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiObject, Object>>,
                Option<Vec<*mut atspi_sys::AtspiObject>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Object],
            ) -> (*mut *mut atspi_sys::AtspiObject, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiObject);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiObject,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Object],
            ) -> (*mut *mut atspi_sys::AtspiObject, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiObject>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiObject;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Object]) -> *mut *mut atspi_sys::AtspiObject {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiObject>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiObject;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiObject>
            for Object
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiObject, Object>>,
                Option<Vec<*mut atspi_sys::AtspiObject>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Object],
            ) -> (*const *mut atspi_sys::AtspiObject, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiObject,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiObject, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Object],
            ) -> (*const *mut atspi_sys::AtspiObject, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/object.rs", 9u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Object]) -> *const *mut atspi_sys::AtspiObject {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/object.rs", 9u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiObject> for Object {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiObject) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/object.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                Object(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiObject> for Object {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiObject) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/object.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                Object(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiObject> for Object {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiObject) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/object.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                Object(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiObject> for Object {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiObject) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/object.rs" , 9u32 , 1u32 ) )
                        }
                    };
                };
                Object(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiObject> for Object {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiObject) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiObject)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiObject,
                *mut *mut atspi_sys::AtspiObject,
            > for Object
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiObject,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiObject,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiObject,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiObject,
                *mut *mut atspi_sys::AtspiObject,
            > for Object
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiObject) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiObject,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiObject) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiObject,
                *const *mut atspi_sys::AtspiObject,
            > for Object
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiObject,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiObject,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/object.rs", 9u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiObject,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/object.rs", 9u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiObject,
                *const *mut atspi_sys::AtspiObject,
            > for Object
        {
            unsafe fn from_glib_none_as_vec(ptr: *const *mut atspi_sys::AtspiObject) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiObject,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/object.rs", 9u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiObject) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/object.rs", 9u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Object {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_object_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Object {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Object {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Object {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Object {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Object")
                    .field("inner", &self.0)
                    .field("type", &<Object as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Object {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Object>::from_glib_none(obj as *mut atspi_sys::AtspiObject)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Object {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiObject>::to_glib_none(this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Object {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiObject>::to_glib_none(&this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        impl ::std::ops::Deref for ObjectClass {
            type Target = <::glib::object::Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for ObjectClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        #[repr(C)]
        pub struct ObjectClass(atspi_sys::AtspiObjectClass);
        unsafe impl ::glib::object::IsClassFor for ObjectClass {
            type Instance = Object;
        }
        unsafe impl Send for ObjectClass {}
        unsafe impl Sync for ObjectClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Object {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Object {}
        impl Object {}
        pub const NONE_OBJECT: Option<&Object> = None;
        impl fmt::Display for Object {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Object"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::object::{Object, ObjectClass, NONE_OBJECT};
    mod relation {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use Accessible;
        use RelationType;
        pub struct Relation(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiRelation>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Relation {
            #[inline]
            fn clone(&self) -> Relation {
                match *self {
                    Relation(ref __self_0_0, ref __self_0_1) => Relation(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Relation {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Relation(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Relation {
            #[inline]
            fn cmp(&self, other: &Relation) -> ::core::cmp::Ordering {
                match *other {
                    Relation(ref __self_1_0, ref __self_1_1) => match *self {
                        Relation(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Relation {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Relation {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Relation(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Relation {
            type GlibType = *mut atspi_sys::AtspiRelation;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Relation {
            type GlibType = atspi_sys::AtspiRelation;
            type GlibClassType = atspi_sys::AtspiRelationClass;
            type RustClassType = RelationClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Relation {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Relation> for Relation {
            fn as_ref(&self) -> &Relation {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Relation> for Relation {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiRelation> for Relation {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiRelation, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiRelation {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiRelation> for Relation {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiRelation, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiRelation {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiRelation>
            for Relation
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiRelation, Relation>>,
                Option<Vec<*mut atspi_sys::AtspiRelation>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Relation],
            ) -> (*mut *mut atspi_sys::AtspiRelation, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiRelation);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiRelation,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Relation],
            ) -> (*mut *mut atspi_sys::AtspiRelation, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiRelation>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiRelation;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Relation]) -> *mut *mut atspi_sys::AtspiRelation {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiRelation>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiRelation;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiRelation>
            for Relation
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiRelation, Relation>>,
                Option<Vec<*mut atspi_sys::AtspiRelation>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Relation],
            ) -> (*const *mut atspi_sys::AtspiRelation, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiRelation,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiRelation, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Relation],
            ) -> (*const *mut atspi_sys::AtspiRelation, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/relation.rs", 12u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Relation]) -> *const *mut atspi_sys::AtspiRelation {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/relation.rs", 12u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiRelation> for Relation {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiRelation) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/relation.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Relation(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiRelation> for Relation {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiRelation) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/relation.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Relation(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiRelation> for Relation {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiRelation) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/relation.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Relation(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiRelation> for Relation {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiRelation) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/relation.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Relation(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiRelation> for Relation {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiRelation) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiRelation)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiRelation,
                *mut *mut atspi_sys::AtspiRelation,
            > for Relation
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRelation,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRelation,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRelation,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiRelation,
                *mut *mut atspi_sys::AtspiRelation,
            > for Relation
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiRelation) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRelation,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiRelation) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiRelation,
                *const *mut atspi_sys::AtspiRelation,
            > for Relation
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiRelation,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiRelation,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/relation.rs", 12u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiRelation,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/relation.rs", 12u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiRelation,
                *const *mut atspi_sys::AtspiRelation,
            > for Relation
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiRelation,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiRelation,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/relation.rs", 12u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiRelation) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/relation.rs", 12u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Relation {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_relation_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Relation {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Relation {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Relation {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Relation {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Relation")
                    .field("inner", &self.0)
                    .field("type", &<Relation as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Relation {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Relation>::from_glib_none(obj as *mut atspi_sys::AtspiRelation)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Relation {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiRelation>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Relation {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiRelation>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        impl ::std::ops::Deref for RelationClass {
            type Target = <::glib::object::Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for RelationClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        #[repr(C)]
        pub struct RelationClass(atspi_sys::AtspiRelationClass);
        unsafe impl ::glib::object::IsClassFor for RelationClass {
            type Instance = Relation;
        }
        unsafe impl Send for RelationClass {}
        unsafe impl Sync for RelationClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Relation {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Relation {}
        pub const NONE_RELATION: Option<&Relation> = None;
        pub trait RelationExt: 'static {
            fn get_n_targets(&self) -> i32;
            fn get_relation_type(&self) -> RelationType;
            fn get_target(&self, i: i32) -> Option<Accessible>;
        }
        impl<O: IsA<Relation>> RelationExt for O {
            fn get_n_targets(&self) -> i32 {
                unsafe { atspi_sys::atspi_relation_get_n_targets(self.as_ref().to_glib_none().0) }
            }
            fn get_relation_type(&self) -> RelationType {
                unsafe {
                    from_glib(atspi_sys::atspi_relation_get_relation_type(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn get_target(&self, i: i32) -> Option<Accessible> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_relation_get_target(
                        self.as_ref().to_glib_none().0,
                        i,
                    ))
                }
            }
        }
        impl fmt::Display for Relation {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Relation"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::relation::RelationExt;
    pub use self::relation::{Relation, RelationClass, NONE_RELATION};
    mod selection {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use std::ptr;
        use Accessible;
        use Error;
        pub struct Selection(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiSelection>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Selection {
            #[inline]
            fn clone(&self) -> Selection {
                match *self {
                    Selection(ref __self_0_0, ref __self_0_1) => Selection(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Selection {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Selection(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Selection {
            #[inline]
            fn cmp(&self, other: &Selection) -> ::core::cmp::Ordering {
                match *other {
                    Selection(ref __self_1_0, ref __self_1_1) => match *self {
                        Selection(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Selection {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Selection {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Selection(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Selection {
            type GlibType = *mut atspi_sys::AtspiSelection;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Selection {
            type GlibType = atspi_sys::AtspiSelection;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Selection {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Selection> for Selection {
            fn as_ref(&self) -> &Selection {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Selection> for Selection {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiSelection> for Selection {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiSelection, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiSelection {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiSelection> for Selection {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiSelection, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiSelection {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiSelection>
            for Selection
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiSelection, Selection>>,
                Option<Vec<*mut atspi_sys::AtspiSelection>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Selection],
            ) -> (*mut *mut atspi_sys::AtspiSelection, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiSelection);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiSelection,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Selection],
            ) -> (*mut *mut atspi_sys::AtspiSelection, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiSelection>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiSelection;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Selection]) -> *mut *mut atspi_sys::AtspiSelection {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiSelection>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiSelection;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiSelection>
            for Selection
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiSelection, Selection>>,
                Option<Vec<*mut atspi_sys::AtspiSelection>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Selection],
            ) -> (*const *mut atspi_sys::AtspiSelection, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiSelection,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiSelection, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Selection],
            ) -> (*const *mut atspi_sys::AtspiSelection, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/selection.rs", 13u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Selection]) -> *const *mut atspi_sys::AtspiSelection {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/selection.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiSelection> for Selection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiSelection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/selection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Selection(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiSelection> for Selection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiSelection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/selection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Selection(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiSelection> for Selection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiSelection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/selection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Selection(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiSelection> for Selection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiSelection) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/selection.rs" , 13u32 , 1u32 ) )
                        }
                    };
                };
                Selection(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiSelection> for Selection {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiSelection) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiSelection)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiSelection,
                *mut *mut atspi_sys::AtspiSelection,
            > for Selection
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiSelection,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiSelection,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiSelection,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiSelection,
                *mut *mut atspi_sys::AtspiSelection,
            > for Selection
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiSelection) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiSelection,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiSelection) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiSelection,
                *const *mut atspi_sys::AtspiSelection,
            > for Selection
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiSelection,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiSelection,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/selection.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiSelection,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/selection.rs", 13u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiSelection,
                *const *mut atspi_sys::AtspiSelection,
            > for Selection
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiSelection,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiSelection,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/selection.rs", 13u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiSelection) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/selection.rs", 13u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Selection {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_selection_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Selection {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Selection {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Selection {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Selection {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Selection")
                    .field("inner", &self.0)
                    .field("type", &<Selection as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Selection {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Selection>::from_glib_none(obj as *mut atspi_sys::AtspiSelection)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Selection {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiSelection>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Selection {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiSelection>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Selection {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Selection {}
        pub const NONE_SELECTION: Option<&Selection> = None;
        pub trait SelectionExt: 'static {
            fn clear_selection(&self) -> Result<(), Error>;
            fn deselect_child(&self, child_index: i32) -> Result<(), Error>;
            fn deselect_selected_child(&self, selected_child_index: i32) -> Result<(), Error>;
            fn get_n_selected_children(&self) -> Result<i32, Error>;
            fn get_selected_child(&self, selected_child_index: i32) -> Result<Accessible, Error>;
            fn is_child_selected(&self, child_index: i32) -> Result<(), Error>;
            fn select_all(&self) -> Result<(), Error>;
            fn select_child(&self, child_index: i32) -> Result<(), Error>;
        }
        impl<O: IsA<Selection>> SelectionExt for O {
            fn clear_selection(&self) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_selection_clear_selection(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn deselect_child(&self, child_index: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_selection_deselect_child(
                        self.as_ref().to_glib_none().0,
                        child_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn deselect_selected_child(&self, selected_child_index: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_selection_deselect_selected_child(
                        self.as_ref().to_glib_none().0,
                        selected_child_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_selected_children(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_selection_get_n_selected_children(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_selected_child(&self, selected_child_index: i32) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_selection_get_selected_child(
                        self.as_ref().to_glib_none().0,
                        selected_child_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn is_child_selected(&self, child_index: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_selection_is_child_selected(
                        self.as_ref().to_glib_none().0,
                        child_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn select_all(&self) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_selection_select_all(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn select_child(&self, child_index: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_selection_select_child(
                        self.as_ref().to_glib_none().0,
                        child_index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Selection {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Selection"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::selection::SelectionExt;
    pub use self::selection::{Selection, NONE_SELECTION};
    mod state_set {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use StateType;
        pub struct StateSet(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiStateSet>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StateSet {
            #[inline]
            fn clone(&self) -> StateSet {
                match *self {
                    StateSet(ref __self_0_0, ref __self_0_1) => StateSet(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for StateSet {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    StateSet(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for StateSet {
            #[inline]
            fn cmp(&self, other: &StateSet) -> ::core::cmp::Ordering {
                match *other {
                    StateSet(ref __self_1_0, ref __self_1_1) => match *self {
                        StateSet(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for StateSet {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for StateSet {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                StateSet(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for StateSet {
            type GlibType = *mut atspi_sys::AtspiStateSet;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for StateSet {
            type GlibType = atspi_sys::AtspiStateSet;
            type GlibClassType = atspi_sys::AtspiStateSetClass;
            type RustClassType = StateSetClass;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for StateSet {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<StateSet> for StateSet {
            fn as_ref(&self) -> &StateSet {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<StateSet> for StateSet {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiStateSet> for StateSet {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiStateSet, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiStateSet {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiStateSet> for StateSet {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiStateSet, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiStateSet {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiStateSet>
            for StateSet
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiStateSet, StateSet>>,
                Option<Vec<*mut atspi_sys::AtspiStateSet>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [StateSet],
            ) -> (*mut *mut atspi_sys::AtspiStateSet, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiStateSet);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiStateSet,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [StateSet],
            ) -> (*mut *mut atspi_sys::AtspiStateSet, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiStateSet>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiStateSet;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[StateSet]) -> *mut *mut atspi_sys::AtspiStateSet {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiStateSet>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiStateSet;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiStateSet>
            for StateSet
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiStateSet, StateSet>>,
                Option<Vec<*mut atspi_sys::AtspiStateSet>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [StateSet],
            ) -> (*const *mut atspi_sys::AtspiStateSet, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiStateSet,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiStateSet, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [StateSet],
            ) -> (*const *mut atspi_sys::AtspiStateSet, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/state_set.rs", 11u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[StateSet]) -> *const *mut atspi_sys::AtspiStateSet {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/state_set.rs", 11u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiStateSet> for StateSet {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiStateSet) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/state_set.rs" , 11u32 , 1u32 ) )
                        }
                    };
                };
                StateSet(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiStateSet> for StateSet {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiStateSet) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/state_set.rs" , 11u32 , 1u32 ) )
                        }
                    };
                };
                StateSet(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiStateSet> for StateSet {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiStateSet) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/state_set.rs" , 11u32 , 1u32 ) )
                        }
                    };
                };
                StateSet(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiStateSet> for StateSet {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiStateSet) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/state_set.rs" , 11u32 , 1u32 ) )
                        }
                    };
                };
                StateSet(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiStateSet> for StateSet {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiStateSet) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiStateSet)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiStateSet,
                *mut *mut atspi_sys::AtspiStateSet,
            > for StateSet
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiStateSet,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiStateSet,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiStateSet,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiStateSet,
                *mut *mut atspi_sys::AtspiStateSet,
            > for StateSet
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiStateSet) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiStateSet,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiStateSet) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiStateSet,
                *const *mut atspi_sys::AtspiStateSet,
            > for StateSet
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiStateSet,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiStateSet,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/state_set.rs", 11u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiStateSet,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/state_set.rs", 11u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiStateSet,
                *const *mut atspi_sys::AtspiStateSet,
            > for StateSet
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiStateSet,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiStateSet,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/state_set.rs", 11u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiStateSet) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/state_set.rs", 11u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for StateSet {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_state_set_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for StateSet {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for StateSet {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for StateSet {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for StateSet {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("StateSet")
                    .field("inner", &self.0)
                    .field("type", &<StateSet as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for StateSet {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<StateSet>::from_glib_none(obj as *mut atspi_sys::AtspiStateSet)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for StateSet {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiStateSet>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for StateSet {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiStateSet>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        impl ::std::ops::Deref for StateSetClass {
            type Target = <::glib::object::Object as ::glib::object::ObjectType>::RustClassType;
            fn deref(&self) -> &Self::Target {
                ::glib::object::IsClassFor::upcast_ref(self)
            }
        }
        impl ::std::ops::DerefMut for StateSetClass {
            fn deref_mut(&mut self) -> &mut Self::Target {
                ::glib::object::IsClassFor::upcast_ref_mut(self)
            }
        }
        #[repr(C)]
        pub struct StateSetClass(atspi_sys::AtspiStateSetClass);
        unsafe impl ::glib::object::IsClassFor for StateSetClass {
            type Instance = StateSet;
        }
        unsafe impl Send for StateSetClass {}
        unsafe impl Sync for StateSetClass {}
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for StateSet {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for StateSet {}
        impl StateSet {}
        pub const NONE_STATE_SET: Option<&StateSet> = None;
        pub trait StateSetExt: 'static {
            fn add(&self, state: StateType);
            fn compare<P: IsA<StateSet>>(&self, set2: &P) -> Option<StateSet>;
            fn contains(&self, state: StateType) -> bool;
            fn equals<P: IsA<StateSet>>(&self, set2: &P) -> bool;
            fn is_empty(&self) -> bool;
            fn remove(&self, state: StateType);
            fn set_by_name(&self, name: &str, enabled: bool);
        }
        impl<O: IsA<StateSet>> StateSetExt for O {
            fn add(&self, state: StateType) {
                unsafe {
                    atspi_sys::atspi_state_set_add(self.as_ref().to_glib_none().0, state.to_glib());
                }
            }
            fn compare<P: IsA<StateSet>>(&self, set2: &P) -> Option<StateSet> {
                unsafe {
                    from_glib_full(atspi_sys::atspi_state_set_compare(
                        self.as_ref().to_glib_none().0,
                        set2.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn contains(&self, state: StateType) -> bool {
                unsafe {
                    from_glib(atspi_sys::atspi_state_set_contains(
                        self.as_ref().to_glib_none().0,
                        state.to_glib(),
                    ))
                }
            }
            fn equals<P: IsA<StateSet>>(&self, set2: &P) -> bool {
                unsafe {
                    from_glib(atspi_sys::atspi_state_set_equals(
                        self.as_ref().to_glib_none().0,
                        set2.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn is_empty(&self) -> bool {
                unsafe {
                    from_glib(atspi_sys::atspi_state_set_is_empty(
                        self.as_ref().to_glib_none().0,
                    ))
                }
            }
            fn remove(&self, state: StateType) {
                unsafe {
                    atspi_sys::atspi_state_set_remove(
                        self.as_ref().to_glib_none().0,
                        state.to_glib(),
                    );
                }
            }
            fn set_by_name(&self, name: &str, enabled: bool) {
                unsafe {
                    atspi_sys::atspi_state_set_set_by_name(
                        self.as_ref().to_glib_none().0,
                        name.to_glib_none().0,
                        enabled.to_glib(),
                    );
                }
            }
        }
        impl fmt::Display for StateSet {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["StateSet"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::state_set::StateSetExt;
    pub use self::state_set::{StateSet, StateSetClass, NONE_STATE_SET};
    mod table {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::mem;
        use std::ptr;
        use Accessible;
        use Error;
        pub struct Table(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiTable>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Table {
            #[inline]
            fn clone(&self) -> Table {
                match *self {
                    Table(ref __self_0_0, ref __self_0_1) => Table(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Table {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Table(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Table {
            #[inline]
            fn cmp(&self, other: &Table) -> ::core::cmp::Ordering {
                match *other {
                    Table(ref __self_1_0, ref __self_1_1) => match *self {
                        Table(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Table {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Table {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Table(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Table {
            type GlibType = *mut atspi_sys::AtspiTable;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Table {
            type GlibType = atspi_sys::AtspiTable;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Table {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Table> for Table {
            fn as_ref(&self) -> &Table {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Table> for Table {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiTable> for Table {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiTable, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiTable {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiTable> for Table {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiTable, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiTable {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiTable>
            for Table
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiTable, Table>>,
                Option<Vec<*mut atspi_sys::AtspiTable>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Table],
            ) -> (*mut *mut atspi_sys::AtspiTable, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiTable);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiTable,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Table],
            ) -> (*mut *mut atspi_sys::AtspiTable, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiTable>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiTable;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Table]) -> *mut *mut atspi_sys::AtspiTable {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiTable>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiTable;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiTable>
            for Table
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiTable, Table>>,
                Option<Vec<*mut atspi_sys::AtspiTable>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Table],
            ) -> (*const *mut atspi_sys::AtspiTable, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiTable,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiTable, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Table],
            ) -> (*const *mut atspi_sys::AtspiTable, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table.rs", 15u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Table]) -> *const *mut atspi_sys::AtspiTable {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table.rs", 15u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiTable> for Table {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiTable) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table.rs" , 15u32 , 1u32 ) )
                        }
                    };
                };
                Table(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiTable> for Table {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiTable) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table.rs" , 15u32 , 1u32 ) )
                        }
                    };
                };
                Table(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiTable> for Table {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiTable) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table.rs" , 15u32 , 1u32 ) )
                        }
                    };
                };
                Table(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiTable> for Table {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiTable) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table.rs" , 15u32 , 1u32 ) )
                        }
                    };
                };
                Table(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiTable> for Table {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiTable) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiTable)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiTable,
                *mut *mut atspi_sys::AtspiTable,
            > for Table
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTable,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTable,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTable,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiTable,
                *mut *mut atspi_sys::AtspiTable,
            > for Table
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiTable) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTable,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiTable) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiTable,
                *const *mut atspi_sys::AtspiTable,
            > for Table
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiTable,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiTable,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table.rs", 15u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiTable,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table.rs", 15u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiTable,
                *const *mut atspi_sys::AtspiTable,
            > for Table
        {
            unsafe fn from_glib_none_as_vec(ptr: *const *mut atspi_sys::AtspiTable) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiTable,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table.rs", 15u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiTable) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table.rs", 15u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Table {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_table_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Table {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Table {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Table {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Table {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Table")
                    .field("inner", &self.0)
                    .field("type", &<Table as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Table {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Table>::from_glib_none(obj as *mut atspi_sys::AtspiTable)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Table {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiTable>::to_glib_none(this).0
                        as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Table {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiTable>::to_glib_none(&this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Table {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Table {}
        pub const NONE_TABLE: Option<&Table> = None;
        pub trait TableExt: 'static {
            fn add_column_selection(&self, column: i32) -> Result<(), Error>;
            fn add_row_selection(&self, row: i32) -> Result<(), Error>;
            fn get_accessible_at(&self, row: i32, column: i32) -> Result<Accessible, Error>;
            fn get_caption(&self) -> Result<Accessible, Error>;
            fn get_column_at_index(&self, index: i32) -> Result<i32, Error>;
            fn get_column_description(&self, column: i32) -> Result<GString, Error>;
            fn get_column_extent_at(&self, row: i32, column: i32) -> Result<i32, Error>;
            fn get_column_header(&self, column: i32) -> Result<Accessible, Error>;
            fn get_index_at(&self, row: i32, column: i32) -> Result<i32, Error>;
            fn get_n_columns(&self) -> Result<i32, Error>;
            fn get_n_rows(&self) -> Result<i32, Error>;
            fn get_n_selected_columns(&self) -> Result<i32, Error>;
            fn get_n_selected_rows(&self) -> Result<i32, Error>;
            fn get_row_at_index(&self, index: i32) -> Result<i32, Error>;
            fn get_row_column_extents_at_index(
                &self,
                index: i32,
            ) -> Result<(i32, i32, i32, i32, bool), Error>;
            fn get_row_description(&self, row: i32) -> Result<GString, Error>;
            fn get_row_extent_at(&self, row: i32, column: i32) -> Result<i32, Error>;
            fn get_row_header(&self, row: i32) -> Result<Accessible, Error>;
            fn get_summary(&self) -> Result<Accessible, Error>;
            fn is_column_selected(&self, column: i32) -> Result<(), Error>;
            fn is_row_selected(&self, row: i32) -> Result<(), Error>;
            fn is_selected(&self, row: i32, column: i32) -> Result<(), Error>;
            fn remove_column_selection(&self, column: i32) -> Result<(), Error>;
            fn remove_row_selection(&self, row: i32) -> Result<(), Error>;
        }
        impl<O: IsA<Table>> TableExt for O {
            fn add_column_selection(&self, column: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_add_column_selection(
                        self.as_ref().to_glib_none().0,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn add_row_selection(&self, row: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_add_row_selection(
                        self.as_ref().to_glib_none().0,
                        row,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_accessible_at(&self, row: i32, column: i32) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_accessible_at(
                        self.as_ref().to_glib_none().0,
                        row,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_caption(&self) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_caption(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_column_at_index(&self, index: i32) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_column_at_index(
                        self.as_ref().to_glib_none().0,
                        index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_column_description(&self, column: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_column_description(
                        self.as_ref().to_glib_none().0,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_column_extent_at(&self, row: i32, column: i32) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_column_extent_at(
                        self.as_ref().to_glib_none().0,
                        row,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_column_header(&self, column: i32) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_column_header(
                        self.as_ref().to_glib_none().0,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_index_at(&self, row: i32, column: i32) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_index_at(
                        self.as_ref().to_glib_none().0,
                        row,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_columns(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_n_columns(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_rows(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_n_rows(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_selected_columns(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_n_selected_columns(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_selected_rows(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_n_selected_rows(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_at_index(&self, index: i32) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_row_at_index(
                        self.as_ref().to_glib_none().0,
                        index,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_column_extents_at_index(
                &self,
                index: i32,
            ) -> Result<(i32, i32, i32, i32, bool), Error> {
                unsafe {
                    let mut row = mem::MaybeUninit::uninit();
                    let mut col = mem::MaybeUninit::uninit();
                    let mut row_extents = mem::MaybeUninit::uninit();
                    let mut col_extents = mem::MaybeUninit::uninit();
                    let mut is_selected = mem::MaybeUninit::uninit();
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_get_row_column_extents_at_index(
                        self.as_ref().to_glib_none().0,
                        index,
                        row.as_mut_ptr(),
                        col.as_mut_ptr(),
                        row_extents.as_mut_ptr(),
                        col_extents.as_mut_ptr(),
                        is_selected.as_mut_ptr(),
                        &mut error,
                    );
                    let row = row.assume_init();
                    let col = col.assume_init();
                    let row_extents = row_extents.assume_init();
                    let col_extents = col_extents.assume_init();
                    let is_selected = is_selected.assume_init();
                    if error.is_null() {
                        Ok((row, col, row_extents, col_extents, from_glib(is_selected)))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_description(&self, row: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_row_description(
                        self.as_ref().to_glib_none().0,
                        row,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_extent_at(&self, row: i32, column: i32) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_row_extent_at(
                        self.as_ref().to_glib_none().0,
                        row,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_header(&self, row: i32) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_row_header(
                        self.as_ref().to_glib_none().0,
                        row,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_summary(&self) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_get_summary(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn is_column_selected(&self, column: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_is_column_selected(
                        self.as_ref().to_glib_none().0,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn is_row_selected(&self, row: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_is_row_selected(
                        self.as_ref().to_glib_none().0,
                        row,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn is_selected(&self, row: i32, column: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_is_selected(
                        self.as_ref().to_glib_none().0,
                        row,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn remove_column_selection(&self, column: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_remove_column_selection(
                        self.as_ref().to_glib_none().0,
                        column,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn remove_row_selection(&self, row: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_remove_row_selection(
                        self.as_ref().to_glib_none().0,
                        row,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Table {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Table"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::table::TableExt;
    pub use self::table::{Table, NONE_TABLE};
    mod table_cell {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use std::mem;
        use std::ptr;
        use Accessible;
        use Error;
        pub struct TableCell(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiTableCell>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TableCell {
            #[inline]
            fn clone(&self) -> TableCell {
                match *self {
                    TableCell(ref __self_0_0, ref __self_0_1) => TableCell(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for TableCell {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    TableCell(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for TableCell {
            #[inline]
            fn cmp(&self, other: &TableCell) -> ::core::cmp::Ordering {
                match *other {
                    TableCell(ref __self_1_0, ref __self_1_1) => match *self {
                        TableCell(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for TableCell {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for TableCell {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                TableCell(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for TableCell {
            type GlibType = *mut atspi_sys::AtspiTableCell;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for TableCell {
            type GlibType = atspi_sys::AtspiTableCell;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for TableCell {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<TableCell> for TableCell {
            fn as_ref(&self) -> &TableCell {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<TableCell> for TableCell {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiTableCell> for TableCell {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiTableCell, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiTableCell {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiTableCell> for TableCell {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiTableCell, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiTableCell {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiTableCell>
            for TableCell
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiTableCell, TableCell>>,
                Option<Vec<*mut atspi_sys::AtspiTableCell>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [TableCell],
            ) -> (*mut *mut atspi_sys::AtspiTableCell, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiTableCell);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiTableCell,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [TableCell],
            ) -> (*mut *mut atspi_sys::AtspiTableCell, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiTableCell>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiTableCell;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[TableCell]) -> *mut *mut atspi_sys::AtspiTableCell {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiTableCell>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiTableCell;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiTableCell>
            for TableCell
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiTableCell, TableCell>>,
                Option<Vec<*mut atspi_sys::AtspiTableCell>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [TableCell],
            ) -> (*const *mut atspi_sys::AtspiTableCell, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiTableCell,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiTableCell, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [TableCell],
            ) -> (*const *mut atspi_sys::AtspiTableCell, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table_cell.rs", 14u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[TableCell]) -> *const *mut atspi_sys::AtspiTableCell {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table_cell.rs", 14u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiTableCell> for TableCell {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiTableCell) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table_cell.rs" , 14u32 , 1u32 ) )
                        }
                    };
                };
                TableCell(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiTableCell> for TableCell {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiTableCell) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table_cell.rs" , 14u32 , 1u32 ) )
                        }
                    };
                };
                TableCell(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiTableCell> for TableCell {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiTableCell) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table_cell.rs" , 14u32 , 1u32 ) )
                        }
                    };
                };
                TableCell(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiTableCell> for TableCell {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiTableCell) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/table_cell.rs" , 14u32 , 1u32 ) )
                        }
                    };
                };
                TableCell(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiTableCell> for TableCell {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiTableCell) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiTableCell)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiTableCell,
                *mut *mut atspi_sys::AtspiTableCell,
            > for TableCell
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTableCell,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTableCell,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTableCell,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiTableCell,
                *mut *mut atspi_sys::AtspiTableCell,
            > for TableCell
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiTableCell) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTableCell,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiTableCell) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiTableCell,
                *const *mut atspi_sys::AtspiTableCell,
            > for TableCell
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiTableCell,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiTableCell,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table_cell.rs", 14u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiTableCell,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table_cell.rs", 14u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiTableCell,
                *const *mut atspi_sys::AtspiTableCell,
            > for TableCell
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *const *mut atspi_sys::AtspiTableCell,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiTableCell,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table_cell.rs", 14u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiTableCell) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/table_cell.rs", 14u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for TableCell {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_table_cell_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for TableCell {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for TableCell {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for TableCell {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for TableCell {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("TableCell")
                    .field("inner", &self.0)
                    .field("type", &<TableCell as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for TableCell {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<TableCell>::from_glib_none(obj as *mut atspi_sys::AtspiTableCell)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for TableCell {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiTableCell>::to_glib_none(
                        this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for TableCell {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiTableCell>::to_glib_none(
                        &this,
                    )
                    .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for TableCell {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for TableCell {}
        pub const NONE_TABLE_CELL: Option<&TableCell> = None;
        pub trait TableCellExt: 'static {
            fn get_column_index(&self) -> Result<i32, Error>;
            fn get_column_span(&self) -> Result<i32, Error>;
            fn get_position(&self) -> Result<(i32, i32, i32), Error>;
            fn get_row_column_span(&self) -> Result<(i32, i32, i32, i32), Error>;
            fn get_row_span(&self) -> Result<i32, Error>;
            fn get_table(&self) -> Result<Accessible, Error>;
        }
        impl<O: IsA<TableCell>> TableCellExt for O {
            fn get_column_index(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_cell_get_column_index(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_column_span(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_cell_get_column_span(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_position(&self) -> Result<(i32, i32, i32), Error> {
                unsafe {
                    let mut row = mem::MaybeUninit::uninit();
                    let mut column = mem::MaybeUninit::uninit();
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_cell_get_position(
                        self.as_ref().to_glib_none().0,
                        row.as_mut_ptr(),
                        column.as_mut_ptr(),
                        &mut error,
                    );
                    let row = row.assume_init();
                    let column = column.assume_init();
                    if error.is_null() {
                        Ok((ret, row, column))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_column_span(&self) -> Result<(i32, i32, i32, i32), Error> {
                unsafe {
                    let mut row = mem::MaybeUninit::uninit();
                    let mut column = mem::MaybeUninit::uninit();
                    let mut row_span = mem::MaybeUninit::uninit();
                    let mut column_span = mem::MaybeUninit::uninit();
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_table_cell_get_row_column_span(
                        self.as_ref().to_glib_none().0,
                        row.as_mut_ptr(),
                        column.as_mut_ptr(),
                        row_span.as_mut_ptr(),
                        column_span.as_mut_ptr(),
                        &mut error,
                    );
                    let row = row.assume_init();
                    let column = column.assume_init();
                    let row_span = row_span.assume_init();
                    let column_span = column_span.assume_init();
                    if error.is_null() {
                        Ok((row, column, row_span, column_span))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_row_span(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_cell_get_row_span(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_table(&self) -> Result<Accessible, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_table_cell_get_table(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for TableCell {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["TableCell"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::table_cell::TableCellExt;
    pub use self::table_cell::{TableCell, NONE_TABLE_CELL};
    mod text {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use glib::GString;
        use std::fmt;
        use std::ptr;
        use CoordType;
        use Error;
        use Range;
        use Rect;
        use TextBoundaryType;
        use TextGranularity;
        use TextRange;
        pub struct Text(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiText>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Text {
            #[inline]
            fn clone(&self) -> Text {
                match *self {
                    Text(ref __self_0_0, ref __self_0_1) => Text(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Text {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Text(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Text {
            #[inline]
            fn cmp(&self, other: &Text) -> ::core::cmp::Ordering {
                match *other {
                    Text(ref __self_1_0, ref __self_1_1) => match *self {
                        Text(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Text {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Text {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Text(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Text {
            type GlibType = *mut atspi_sys::AtspiText;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Text {
            type GlibType = atspi_sys::AtspiText;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Text {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Text> for Text {
            fn as_ref(&self) -> &Text {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Text> for Text {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiText> for Text {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiText, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiText {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiText> for Text {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiText, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiText {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiText> for Text {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiText, Text>>,
                Option<Vec<*mut atspi_sys::AtspiText>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Text],
            ) -> (*mut *mut atspi_sys::AtspiText, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiText);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiText,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Text],
            ) -> (*mut *mut atspi_sys::AtspiText, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiText>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiText;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Text]) -> *mut *mut atspi_sys::AtspiText {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiText>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiText;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiText>
            for Text
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiText, Text>>,
                Option<Vec<*mut atspi_sys::AtspiText>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Text],
            ) -> (*const *mut atspi_sys::AtspiText, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiText,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiText, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Text],
            ) -> (*const *mut atspi_sys::AtspiText, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text.rs", 19u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Text]) -> *const *mut atspi_sys::AtspiText {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text.rs", 19u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiText> for Text {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/text.rs" , 19u32 , 1u32 ) )
                        }
                    };
                };
                Text(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiText> for Text {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/text.rs" , 19u32 , 1u32 ) )
                        }
                    };
                };
                Text(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiText> for Text {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/text.rs" , 19u32 , 1u32 ) )
                        }
                    };
                };
                Text(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiText> for Text {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiText) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/text.rs" , 19u32 , 1u32 ) )
                        }
                    };
                };
                Text(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiText> for Text {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiText) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiText)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiText,
                *mut *mut atspi_sys::AtspiText,
            > for Text
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiText,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiText,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiText,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiText,
                *mut *mut atspi_sys::AtspiText,
            > for Text
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiText) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(ptr: *mut *mut atspi_sys::AtspiText) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiText) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiText,
                *const *mut atspi_sys::AtspiText,
            > for Text
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiText,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiText,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text.rs", 19u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiText,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text.rs", 19u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiText,
                *const *mut atspi_sys::AtspiText,
            > for Text
        {
            unsafe fn from_glib_none_as_vec(ptr: *const *mut atspi_sys::AtspiText) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(_: *const *mut atspi_sys::AtspiText) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text.rs", 19u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiText) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text.rs", 19u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Text {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_text_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Text {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Text {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Text {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Text {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Text")
                    .field("inner", &self.0)
                    .field("type", &<Text as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Text {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Text>::from_glib_none(obj as *mut atspi_sys::AtspiText)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Text {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiText>::to_glib_none(this).0
                        as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Text {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiText>::to_glib_none(&this).0
                        as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Text {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Text {}
        pub const NONE_TEXT: Option<&Text> = None;
        pub trait TextExt: 'static {
            fn add_selection(&self, start_offset: i32, end_offset: i32) -> Result<(), Error>;
            fn get_caret_offset(&self) -> Result<i32, Error>;
            fn get_character_at_offset(&self, offset: i32) -> Result<(), Error>;
            fn get_character_count(&self) -> Result<i32, Error>;
            fn get_character_extents(&self, offset: i32, type_: CoordType) -> Result<Rect, Error>;
            fn get_n_selections(&self) -> Result<i32, Error>;
            fn get_offset_at_point(&self, x: i32, y: i32, type_: CoordType) -> Result<i32, Error>;
            fn get_range_extents(
                &self,
                start_offset: i32,
                end_offset: i32,
                type_: CoordType,
            ) -> Result<Rect, Error>;
            fn get_selection(&self, selection_num: i32) -> Result<Range, Error>;
            fn get_string_at_offset(
                &self,
                offset: i32,
                granularity: TextGranularity,
            ) -> Result<TextRange, Error>;
            fn get_text(&self, start_offset: i32, end_offset: i32) -> Result<GString, Error>;
            fn get_text_after_offset(
                &self,
                offset: i32,
                type_: TextBoundaryType,
            ) -> Result<TextRange, Error>;
            fn get_text_attribute_value(
                &self,
                offset: i32,
                attribute_name: &str,
            ) -> Result<Option<GString>, Error>;
            fn get_text_before_offset(
                &self,
                offset: i32,
                type_: TextBoundaryType,
            ) -> Result<TextRange, Error>;
            fn remove_selection(&self, selection_num: i32) -> Result<(), Error>;
            fn set_caret_offset(&self, new_offset: i32) -> Result<(), Error>;
            fn set_selection(
                &self,
                selection_num: i32,
                start_offset: i32,
                end_offset: i32,
            ) -> Result<(), Error>;
        }
        impl<O: IsA<Text>> TextExt for O {
            fn add_selection(&self, start_offset: i32, end_offset: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_text_add_selection(
                        self.as_ref().to_glib_none().0,
                        start_offset,
                        end_offset,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_caret_offset(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_caret_offset(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_character_at_offset(&self, offset: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_text_get_character_at_offset(
                        self.as_ref().to_glib_none().0,
                        offset,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_character_count(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_character_count(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_character_extents(&self, offset: i32, type_: CoordType) -> Result<Rect, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_character_extents(
                        self.as_ref().to_glib_none().0,
                        offset,
                        type_.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_n_selections(&self) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_n_selections(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_offset_at_point(&self, x: i32, y: i32, type_: CoordType) -> Result<i32, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_offset_at_point(
                        self.as_ref().to_glib_none().0,
                        x,
                        y,
                        type_.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_range_extents(
                &self,
                start_offset: i32,
                end_offset: i32,
                type_: CoordType,
            ) -> Result<Rect, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_range_extents(
                        self.as_ref().to_glib_none().0,
                        start_offset,
                        end_offset,
                        type_.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_selection(&self, selection_num: i32) -> Result<Range, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_selection(
                        self.as_ref().to_glib_none().0,
                        selection_num,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_string_at_offset(
                &self,
                offset: i32,
                granularity: TextGranularity,
            ) -> Result<TextRange, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_string_at_offset(
                        self.as_ref().to_glib_none().0,
                        offset,
                        granularity.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_text(&self, start_offset: i32, end_offset: i32) -> Result<GString, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_text(
                        self.as_ref().to_glib_none().0,
                        start_offset,
                        end_offset,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_text_after_offset(
                &self,
                offset: i32,
                type_: TextBoundaryType,
            ) -> Result<TextRange, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_text_after_offset(
                        self.as_ref().to_glib_none().0,
                        offset,
                        type_.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_text_attribute_value(
                &self,
                offset: i32,
                attribute_name: &str,
            ) -> Result<Option<GString>, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_text_attribute_value(
                        self.as_ref().to_glib_none().0,
                        offset,
                        attribute_name.to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_text_before_offset(
                &self,
                offset: i32,
                type_: TextBoundaryType,
            ) -> Result<TextRange, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_text_get_text_before_offset(
                        self.as_ref().to_glib_none().0,
                        offset,
                        type_.to_glib(),
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(from_glib_full(ret))
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn remove_selection(&self, selection_num: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_text_remove_selection(
                        self.as_ref().to_glib_none().0,
                        selection_num,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_caret_offset(&self, new_offset: i32) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_text_set_caret_offset(
                        self.as_ref().to_glib_none().0,
                        new_offset,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_selection(
                &self,
                selection_num: i32,
                start_offset: i32,
                end_offset: i32,
            ) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_text_set_selection(
                        self.as_ref().to_glib_none().0,
                        selection_num,
                        start_offset,
                        end_offset,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Text {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Text"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::text::TextExt;
    pub use self::text::{Text, NONE_TEXT};
    mod value {
        use atspi_sys;
        use glib::object::IsA;
        use glib::translate::*;
        use std::fmt;
        use std::ptr;
        use Error;
        pub struct Value(
            ::glib::object::ObjectRef,
            ::std::marker::PhantomData<atspi_sys::AtspiValue>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Value {
            #[inline]
            fn clone(&self) -> Value {
                match *self {
                    Value(ref __self_0_0, ref __self_0_1) => Value(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Value {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Value(ref __self_0_0, ref __self_0_1) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Value {
            #[inline]
            fn cmp(&self, other: &Value) -> ::core::cmp::Ordering {
                match *other {
                    Value(ref __self_1_0, ref __self_1_1) => match *self {
                        Value(ref __self_0_0, ref __self_0_1) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                        ::core::cmp::Ordering::Equal => {
                                            ::core::cmp::Ordering::Equal
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[doc(hidden)]
        impl Into<::glib::object::ObjectRef> for Value {
            fn into(self) -> ::glib::object::ObjectRef {
                self.0
            }
        }
        #[doc(hidden)]
        impl ::glib::object::UnsafeFrom<::glib::object::ObjectRef> for Value {
            unsafe fn unsafe_from(t: ::glib::object::ObjectRef) -> Self {
                Value(t, ::std::marker::PhantomData)
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Value {
            type GlibType = *mut atspi_sys::AtspiValue;
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::ObjectType for Value {
            type GlibType = atspi_sys::AtspiValue;
            type GlibClassType = ::glib::wrapper::Void;
            type RustClassType = ::glib::wrapper::Void;
            fn as_object_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
            fn as_ptr(&self) -> *mut Self::GlibType {
                self.0.to_glib_none().0 as *mut _
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::ObjectRef> for Value {
            fn as_ref(&self) -> &::glib::object::ObjectRef {
                &self.0
            }
        }
        #[doc(hidden)]
        impl AsRef<Value> for Value {
            fn as_ref(&self) -> &Value {
                self
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<Value> for Value {}
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiValue> for Value {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiValue, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *const _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiValue {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *const _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *mut atspi_sys::AtspiValue> for Value {
            type Storage = <::glib::object::ObjectRef as ::glib::translate::ToGlibPtr<
                'a,
                *mut ::glib::object::GObject,
            >>::Storage;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *mut atspi_sys::AtspiValue, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0 as *mut _, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *mut atspi_sys::AtspiValue {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0) as *mut _
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *mut atspi_sys::AtspiValue>
            for Value
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiValue, Value>>,
                Option<Vec<*mut atspi_sys::AtspiValue>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Value],
            ) -> (*mut *mut atspi_sys::AtspiValue, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *mut atspi_sys::AtspiValue);
                (
                    v_ptr.as_ptr() as *mut *mut atspi_sys::AtspiValue,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Value],
            ) -> (*mut *mut atspi_sys::AtspiValue, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiValue>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiValue;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Value]) -> *mut *mut atspi_sys::AtspiValue {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*mut atspi_sys::AtspiValue>() * (t.len() + 1),
                    ) as *mut *mut atspi_sys::AtspiValue;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *mut atspi_sys::AtspiValue>
            for Value
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *mut atspi_sys::AtspiValue, Value>>,
                Option<Vec<*mut atspi_sys::AtspiValue>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Value],
            ) -> (*const *mut atspi_sys::AtspiValue, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *mut atspi_sys::AtspiValue,
                >::to_glib_none_from_slice(t);
                (ptr as *const *mut atspi_sys::AtspiValue, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Value],
            ) -> (*const *mut atspi_sys::AtspiValue, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/value.rs", 12u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Value]) -> *const *mut atspi_sys::AtspiValue {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/value.rs", 12u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiValue> for Value {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiValue) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/value.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Value(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiValue> for Value {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiValue) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/value.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Value(
                    ::glib::translate::from_glib_none(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiValue> for Value {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiValue) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/value.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Value(
                    ::glib::translate::from_glib_full(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiValue> for Value {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiValue) -> Self {
                if true {
                    if !::glib::types::instance_of::<Self>(ptr as *const _) {
                        {
                            :: std :: rt :: begin_panic ( "assertion failed: ::glib::types::instance_of::<Self>(ptr as *const _)" , & ( "src/auto/value.rs" , 12u32 , 1u32 ) )
                        }
                    };
                };
                Value(
                    ::glib::translate::from_glib_borrow(ptr as *mut _),
                    ::std::marker::PhantomData,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiValue> for Value {
            #[inline]
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiValue) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiValue)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiValue,
                *mut *mut atspi_sys::AtspiValue,
            > for Value
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiValue,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiValue,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiValue,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiValue,
                *mut *mut atspi_sys::AtspiValue,
            > for Value
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiValue) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiValue,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiValue) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiValue,
                *const *mut atspi_sys::AtspiValue,
            > for Value
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *const *mut atspi_sys::AtspiValue,
                num: usize,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr as *mut *mut _,
                    num,
                )
            }
            unsafe fn from_glib_container_num_as_vec(
                _: *const *mut atspi_sys::AtspiValue,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/value.rs", 12u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_num_as_vec(
                _: *const *mut atspi_sys::AtspiValue,
                _: usize,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/value.rs", 12u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiValue,
                *const *mut atspi_sys::AtspiValue,
            > for Value
        {
            unsafe fn from_glib_none_as_vec(ptr: *const *mut atspi_sys::AtspiValue) -> Vec<Self> {
                ::glib::translate::FromGlibPtrArrayContainerAsVec::from_glib_none_as_vec(
                    ptr as *mut *mut _,
                )
            }
            unsafe fn from_glib_container_as_vec(
                _: *const *mut atspi_sys::AtspiValue,
            ) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/value.rs", 12u32, 1u32),
                    )
                }
            }
            unsafe fn from_glib_full_as_vec(_: *const *mut atspi_sys::AtspiValue) -> Vec<Self> {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/value.rs", 12u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Value {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_value_get_type())
                }
            }
        }
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialEq<T> for Value {
            #[inline]
            fn eq(&self, other: &T) -> bool {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0).0
                    == ::glib::translate::ToGlibPtr::to_glib_none(
                        ::glib::object::ObjectType::as_object_ref(other),
                    )
                    .0
            }
        }
        impl ::std::cmp::Eq for Value {}
        impl<T: ::glib::object::ObjectType> ::std::cmp::PartialOrd<T> for Value {
            #[inline]
            fn partial_cmp(&self, other: &T) -> Option<::std::cmp::Ordering> {
                ::glib::translate::ToGlibPtr::to_glib_none(&self.0)
                    .0
                    .partial_cmp(
                        &::glib::translate::ToGlibPtr::to_glib_none(
                            ::glib::object::ObjectType::as_object_ref(other),
                        )
                        .0,
                    )
            }
        }
        impl ::std::fmt::Debug for Value {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                f.debug_struct("Value")
                    .field("inner", &self.0)
                    .field("type", &<Value as ::glib::ObjectExt>::get_type(self))
                    .finish()
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Value {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                let obj = ::glib::gobject_sys::g_value_get_object(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                );
                if !obj.is_null()
                    && ::glib::gobject_sys::g_object_is_floating(obj) != ::glib::glib_sys::GFALSE
                {
                    ::glib::gobject_sys::g_object_ref_sink(obj);
                }
                Option::<Value>::from_glib_none(obj as *mut atspi_sys::AtspiValue)
                    .map(|o| ::glib::object::Cast::unsafe_cast(o))
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Value {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiValue>::to_glib_none(this).0
                        as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Value {
            #[allow(clippy::cast_ptr_alignment)]
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_object(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*mut atspi_sys::AtspiValue>::to_glib_none(&this)
                        .0 as *mut ::glib::gobject_sys::GObject,
                )
            }
        }
        #[doc(hidden)]
        impl AsRef<::glib::object::Object> for Value {
            fn as_ref(&self) -> &::glib::object::Object {
                ::glib::object::Cast::upcast_ref(self)
            }
        }
        #[doc(hidden)]
        unsafe impl ::glib::object::IsA<::glib::object::Object> for Value {}
        pub const NONE_VALUE: Option<&Value> = None;
        pub trait ValueExt: 'static {
            fn get_current_value(&self) -> Result<f64, Error>;
            fn get_maximum_value(&self) -> Result<f64, Error>;
            fn get_minimum_increment(&self) -> Result<f64, Error>;
            fn get_minimum_value(&self) -> Result<f64, Error>;
            fn set_current_value(&self, new_value: f64) -> Result<(), Error>;
        }
        impl<O: IsA<Value>> ValueExt for O {
            fn get_current_value(&self) -> Result<f64, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_value_get_current_value(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_maximum_value(&self) -> Result<f64, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_value_get_maximum_value(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_minimum_increment(&self) -> Result<f64, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_value_get_minimum_increment(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn get_minimum_value(&self) -> Result<f64, Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let ret = atspi_sys::atspi_value_get_minimum_value(
                        self.as_ref().to_glib_none().0,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(ret)
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
            fn set_current_value(&self, new_value: f64) -> Result<(), Error> {
                unsafe {
                    let mut error = ptr::null_mut();
                    let _ = atspi_sys::atspi_value_set_current_value(
                        self.as_ref().to_glib_none().0,
                        new_value,
                        &mut error,
                    );
                    if error.is_null() {
                        Ok(())
                    } else {
                        Err(from_glib_full(error))
                    }
                }
            }
        }
        impl fmt::Display for Value {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Value"],
                    &match () {
                        () => [],
                    },
                ))
            }
        }
    }
    pub use self::value::ValueExt;
    pub use self::value::{Value, NONE_VALUE};
    mod device_event {
        use atspi_sys;
        use gobject_sys;
        pub struct DeviceEvent(::glib::boxed::Boxed<atspi_sys::AtspiDeviceEvent, MemoryManager>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DeviceEvent {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    DeviceEvent(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("DeviceEvent");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for DeviceEvent {
            #[inline]
            fn eq(&self, other: &DeviceEvent) -> bool {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &DeviceEvent) -> bool {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for DeviceEvent {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiDeviceEvent, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for DeviceEvent {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DeviceEvent,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &DeviceEvent) -> bool {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &DeviceEvent) -> bool {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &DeviceEvent) -> bool {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &DeviceEvent) -> bool {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for DeviceEvent {
            #[inline]
            fn cmp(&self, other: &DeviceEvent) -> ::core::cmp::Ordering {
                match *other {
                    DeviceEvent(ref __self_1_0) => match *self {
                        DeviceEvent(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for DeviceEvent {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    DeviceEvent(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DeviceEvent {
            #[inline]
            fn clone(&self) -> DeviceEvent {
                match *self {
                    DeviceEvent(ref __self_0_0) => {
                        DeviceEvent(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for DeviceEvent {
            type GlibType = *mut atspi_sys::AtspiDeviceEvent;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiDeviceEvent, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiDeviceEvent, Self>
            {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiDeviceEvent {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            type Storage = &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiDeviceEvent, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiDeviceEvent, Self>
            {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *const atspi_sys::AtspiDeviceEvent>
            for DeviceEvent
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiDeviceEvent, DeviceEvent>>,
                Option<Vec<*const atspi_sys::AtspiDeviceEvent>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [DeviceEvent],
            ) -> (*mut *const atspi_sys::AtspiDeviceEvent, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiDeviceEvent);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiDeviceEvent,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [DeviceEvent],
            ) -> (*mut *const atspi_sys::AtspiDeviceEvent, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiDeviceEvent>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiDeviceEvent;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(
                t: &[DeviceEvent],
            ) -> *mut *const atspi_sys::AtspiDeviceEvent {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiDeviceEvent>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiDeviceEvent;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<
                'a,
                *const *const atspi_sys::AtspiDeviceEvent,
            > for DeviceEvent
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiDeviceEvent, DeviceEvent>>,
                Option<Vec<*const atspi_sys::AtspiDeviceEvent>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [DeviceEvent],
            ) -> (*const *const atspi_sys::AtspiDeviceEvent, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiDeviceEvent,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiDeviceEvent, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [DeviceEvent],
            ) -> (*const *const atspi_sys::AtspiDeviceEvent, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_event.rs", 8u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(
                _: &[DeviceEvent],
            ) -> *const *const atspi_sys::AtspiDeviceEvent {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_event.rs", 8u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiDeviceEvent) -> Self {
                DeviceEvent(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiDeviceEvent) -> Self {
                DeviceEvent(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiDeviceEvent) -> Self {
                DeviceEvent(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiDeviceEvent) -> Self {
                DeviceEvent(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiDeviceEvent> for DeviceEvent {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiDeviceEvent) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiDeviceEvent)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiDeviceEvent,
                *mut *mut atspi_sys::AtspiDeviceEvent,
            > for DeviceEvent
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceEvent,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceEvent,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceEvent,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiDeviceEvent,
                *mut *mut atspi_sys::AtspiDeviceEvent,
            > for DeviceEvent
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceEvent,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceEvent,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(
                ptr: *mut *mut atspi_sys::AtspiDeviceEvent,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiDeviceEvent> for MemoryManager {
            #[inline]
            unsafe fn copy(
                ptr: *const atspi_sys::AtspiDeviceEvent,
            ) -> *mut atspi_sys::AtspiDeviceEvent {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_device_event_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiDeviceEvent
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiDeviceEvent) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_device_event_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiDeviceEvent) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_event.rs", 8u32, 1u32),
                    )
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiDeviceEvent) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/device_event.rs", 8u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for DeviceEvent {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_device_event_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for DeviceEvent {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                )
                    as *mut atspi_sys::AtspiDeviceEvent)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for DeviceEvent {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                :: glib :: gobject_sys :: g_value_set_boxed ( :: glib :: translate :: ToGlibPtrMut :: to_glib_none_mut ( value ) . 0 , :: glib :: translate :: ToGlibPtr :: < * const atspi_sys :: AtspiDeviceEvent > :: to_glib_none ( this ) . 0 as :: glib :: glib_sys :: gpointer )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for DeviceEvent {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                :: glib :: gobject_sys :: g_value_set_boxed ( :: glib :: translate :: ToGlibPtrMut :: to_glib_none_mut ( value ) . 0 , :: glib :: translate :: ToGlibPtr :: < * const atspi_sys :: AtspiDeviceEvent > :: to_glib_none ( & this ) . 0 as :: glib :: glib_sys :: gpointer )
            }
        }
    }
    pub use self::device_event::DeviceEvent;
    mod event {
        use atspi_sys;
        use gobject_sys;
        pub struct Event(::glib::boxed::Boxed<atspi_sys::AtspiEvent, MemoryManager>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Event {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Event(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("Event");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Event {
            #[inline]
            fn eq(&self, other: &Event) -> bool {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Event) -> bool {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Event {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiEvent, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Event {
            #[inline]
            fn partial_cmp(&self, other: &Event) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &Event) -> bool {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &Event) -> bool {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &Event) -> bool {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &Event) -> bool {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Event {
            #[inline]
            fn cmp(&self, other: &Event) -> ::core::cmp::Ordering {
                match *other {
                    Event(ref __self_1_0) => match *self {
                        Event(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Event {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Event(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Event {
            #[inline]
            fn clone(&self) -> Event {
                match *self {
                    Event(ref __self_0_0) => Event(::core::clone::Clone::clone(&(*__self_0_0))),
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Event {
            type GlibType = *mut atspi_sys::AtspiEvent;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiEvent> for Event {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiEvent, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiEvent, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiEvent {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiEvent> for Event {
            type Storage = &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiEvent, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiEvent, Self> {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *const atspi_sys::AtspiEvent>
            for Event
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiEvent, Event>>,
                Option<Vec<*const atspi_sys::AtspiEvent>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Event],
            ) -> (*mut *const atspi_sys::AtspiEvent, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiEvent);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiEvent,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Event],
            ) -> (*mut *const atspi_sys::AtspiEvent, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiEvent>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiEvent;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Event]) -> *mut *const atspi_sys::AtspiEvent {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiEvent>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiEvent;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *const atspi_sys::AtspiEvent>
            for Event
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiEvent, Event>>,
                Option<Vec<*const atspi_sys::AtspiEvent>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Event],
            ) -> (*const *const atspi_sys::AtspiEvent, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiEvent,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiEvent, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Event],
            ) -> (*const *const atspi_sys::AtspiEvent, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/event.rs", 8u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Event]) -> *const *const atspi_sys::AtspiEvent {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/event.rs", 8u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiEvent> for Event {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiEvent) -> Self {
                Event(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiEvent> for Event {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiEvent) -> Self {
                Event(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiEvent> for Event {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiEvent) -> Self {
                Event(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiEvent> for Event {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiEvent) -> Self {
                Event(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiEvent> for Event {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiEvent) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiEvent)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiEvent,
                *mut *mut atspi_sys::AtspiEvent,
            > for Event
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEvent,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEvent,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEvent,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiEvent,
                *mut *mut atspi_sys::AtspiEvent,
            > for Event
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiEvent) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiEvent,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiEvent) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiEvent> for MemoryManager {
            #[inline]
            unsafe fn copy(ptr: *const atspi_sys::AtspiEvent) -> *mut atspi_sys::AtspiEvent {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_event_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiEvent
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiEvent) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_event_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiEvent) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/event.rs", 8u32, 1u32),
                    )
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiEvent) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/event.rs", 8u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Event {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_event_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Event {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                ) as *mut atspi_sys::AtspiEvent)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Event {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiEvent>::to_glib_none(this)
                        .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Event {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiEvent>::to_glib_none(
                        &this,
                    )
                    .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
        impl Event {
            pub fn main() {
                unsafe {
                    atspi_sys::atspi_event_main();
                }
            }
            pub fn quit() {
                unsafe {
                    atspi_sys::atspi_event_quit();
                }
            }
        }
    }
    pub use self::event::Event;
    mod key_definition {
        use atspi_sys;
        use gobject_sys;
        pub struct KeyDefinition(
            ::glib::boxed::Boxed<atspi_sys::AtspiKeyDefinition, MemoryManager>,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for KeyDefinition {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    KeyDefinition(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("KeyDefinition");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for KeyDefinition {
            #[inline]
            fn eq(&self, other: &KeyDefinition) -> bool {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &KeyDefinition) -> bool {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for KeyDefinition {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiKeyDefinition, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for KeyDefinition {
            #[inline]
            fn partial_cmp(
                &self,
                other: &KeyDefinition,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0_0),
                                &(*__self_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &KeyDefinition) -> bool {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &KeyDefinition) -> bool {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &KeyDefinition) -> bool {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &KeyDefinition) -> bool {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for KeyDefinition {
            #[inline]
            fn cmp(&self, other: &KeyDefinition) -> ::core::cmp::Ordering {
                match *other {
                    KeyDefinition(ref __self_1_0) => match *self {
                        KeyDefinition(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for KeyDefinition {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    KeyDefinition(ref __self_0_0) => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for KeyDefinition {
            #[inline]
            fn clone(&self) -> KeyDefinition {
                match *self {
                    KeyDefinition(ref __self_0_0) => {
                        KeyDefinition(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for KeyDefinition {
            type GlibType = *mut atspi_sys::AtspiKeyDefinition;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiKeyDefinition, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiKeyDefinition, Self>
            {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiKeyDefinition {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            type Storage =
                &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiKeyDefinition, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiKeyDefinition, Self>
            {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<
                'a,
                *mut *const atspi_sys::AtspiKeyDefinition,
            > for KeyDefinition
        {
            type Storage = (
                Vec<
                    ::glib::translate::Stash<
                        'a,
                        *const atspi_sys::AtspiKeyDefinition,
                        KeyDefinition,
                    >,
                >,
                Option<Vec<*const atspi_sys::AtspiKeyDefinition>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [KeyDefinition],
            ) -> (*mut *const atspi_sys::AtspiKeyDefinition, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiKeyDefinition);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiKeyDefinition,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [KeyDefinition],
            ) -> (*mut *const atspi_sys::AtspiKeyDefinition, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiKeyDefinition>()
                            * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiKeyDefinition;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(
                t: &[KeyDefinition],
            ) -> *mut *const atspi_sys::AtspiKeyDefinition {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiKeyDefinition>()
                            * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiKeyDefinition;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<
                'a,
                *const *const atspi_sys::AtspiKeyDefinition,
            > for KeyDefinition
        {
            type Storage = (
                Vec<
                    ::glib::translate::Stash<
                        'a,
                        *const atspi_sys::AtspiKeyDefinition,
                        KeyDefinition,
                    >,
                >,
                Option<Vec<*const atspi_sys::AtspiKeyDefinition>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [KeyDefinition],
            ) -> (*const *const atspi_sys::AtspiKeyDefinition, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiKeyDefinition,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiKeyDefinition, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [KeyDefinition],
            ) -> (*const *const atspi_sys::AtspiKeyDefinition, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/key_definition.rs", 8u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(
                _: &[KeyDefinition],
            ) -> *const *const atspi_sys::AtspiKeyDefinition {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/key_definition.rs", 8u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiKeyDefinition) -> Self {
                KeyDefinition(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiKeyDefinition) -> Self {
                KeyDefinition(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiKeyDefinition) -> Self {
                KeyDefinition(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiKeyDefinition) -> Self {
                KeyDefinition(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiKeyDefinition> for KeyDefinition {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiKeyDefinition) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiKeyDefinition)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiKeyDefinition,
                *mut *mut atspi_sys::AtspiKeyDefinition,
            > for KeyDefinition
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiKeyDefinition,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiKeyDefinition,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiKeyDefinition,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiKeyDefinition,
                *mut *mut atspi_sys::AtspiKeyDefinition,
            > for KeyDefinition
        {
            unsafe fn from_glib_none_as_vec(
                ptr: *mut *mut atspi_sys::AtspiKeyDefinition,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiKeyDefinition,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(
                ptr: *mut *mut atspi_sys::AtspiKeyDefinition,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiKeyDefinition> for MemoryManager {
            #[inline]
            unsafe fn copy(
                ptr: *const atspi_sys::AtspiKeyDefinition,
            ) -> *mut atspi_sys::AtspiKeyDefinition {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_key_definition_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiKeyDefinition
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiKeyDefinition) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_key_definition_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiKeyDefinition) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/key_definition.rs", 8u32, 1u32),
                    )
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiKeyDefinition) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/key_definition.rs", 8u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for KeyDefinition {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_key_definition_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for KeyDefinition {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                )
                    as *mut atspi_sys::AtspiKeyDefinition)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for KeyDefinition {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                :: glib :: gobject_sys :: g_value_set_boxed ( :: glib :: translate :: ToGlibPtrMut :: to_glib_none_mut ( value ) . 0 , :: glib :: translate :: ToGlibPtr :: < * const atspi_sys :: AtspiKeyDefinition > :: to_glib_none ( this ) . 0 as :: glib :: glib_sys :: gpointer )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for KeyDefinition {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                :: glib :: gobject_sys :: g_value_set_boxed ( :: glib :: translate :: ToGlibPtrMut :: to_glib_none_mut ( value ) . 0 , :: glib :: translate :: ToGlibPtr :: < * const atspi_sys :: AtspiKeyDefinition > :: to_glib_none ( & this ) . 0 as :: glib :: glib_sys :: gpointer )
            }
        }
    }
    pub use self::key_definition::KeyDefinition;
    mod point {
        use atspi_sys;
        use gobject_sys;
        pub struct Point(::glib::boxed::Boxed<atspi_sys::AtspiPoint, MemoryManager>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Point {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Point(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("Point");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Point {
            #[inline]
            fn eq(&self, other: &Point) -> bool {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Point) -> bool {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Point {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiPoint, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Point {
            #[inline]
            fn partial_cmp(&self, other: &Point) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &Point) -> bool {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &Point) -> bool {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &Point) -> bool {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &Point) -> bool {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Point {
            #[inline]
            fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {
                match *other {
                    Point(ref __self_1_0) => match *self {
                        Point(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Point {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Point(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Point {
            #[inline]
            fn clone(&self) -> Point {
                match *self {
                    Point(ref __self_0_0) => Point(::core::clone::Clone::clone(&(*__self_0_0))),
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Point {
            type GlibType = *mut atspi_sys::AtspiPoint;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiPoint> for Point {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiPoint, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiPoint, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiPoint {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiPoint> for Point {
            type Storage = &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiPoint, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiPoint, Self> {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *const atspi_sys::AtspiPoint>
            for Point
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiPoint, Point>>,
                Option<Vec<*const atspi_sys::AtspiPoint>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Point],
            ) -> (*mut *const atspi_sys::AtspiPoint, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiPoint);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiPoint,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Point],
            ) -> (*mut *const atspi_sys::AtspiPoint, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiPoint>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiPoint;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Point]) -> *mut *const atspi_sys::AtspiPoint {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiPoint>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiPoint;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *const atspi_sys::AtspiPoint>
            for Point
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiPoint, Point>>,
                Option<Vec<*const atspi_sys::AtspiPoint>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Point],
            ) -> (*const *const atspi_sys::AtspiPoint, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiPoint,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiPoint, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Point],
            ) -> (*const *const atspi_sys::AtspiPoint, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/point.rs", 8u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Point]) -> *const *const atspi_sys::AtspiPoint {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/point.rs", 8u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiPoint> for Point {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiPoint) -> Self {
                Point(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiPoint> for Point {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiPoint) -> Self {
                Point(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiPoint> for Point {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiPoint) -> Self {
                Point(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiPoint> for Point {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiPoint) -> Self {
                Point(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiPoint> for Point {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiPoint) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiPoint)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiPoint,
                *mut *mut atspi_sys::AtspiPoint,
            > for Point
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiPoint,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiPoint,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiPoint,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiPoint,
                *mut *mut atspi_sys::AtspiPoint,
            > for Point
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiPoint) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiPoint,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiPoint) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiPoint> for MemoryManager {
            #[inline]
            unsafe fn copy(ptr: *const atspi_sys::AtspiPoint) -> *mut atspi_sys::AtspiPoint {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_point_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiPoint
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiPoint) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_point_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiPoint) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/point.rs", 8u32, 1u32),
                    )
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiPoint) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/point.rs", 8u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Point {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_point_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Point {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                ) as *mut atspi_sys::AtspiPoint)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Point {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiPoint>::to_glib_none(this)
                        .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Point {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiPoint>::to_glib_none(
                        &this,
                    )
                    .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
    }
    pub use self::point::Point;
    mod range {
        use atspi_sys;
        use gobject_sys;
        pub struct Range(::glib::boxed::Boxed<atspi_sys::AtspiRange, MemoryManager>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Range {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Range(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("Range");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Range {
            #[inline]
            fn eq(&self, other: &Range) -> bool {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Range) -> bool {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Range {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiRange, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Range {
            #[inline]
            fn partial_cmp(&self, other: &Range) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &Range) -> bool {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &Range) -> bool {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &Range) -> bool {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &Range) -> bool {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Range {
            #[inline]
            fn cmp(&self, other: &Range) -> ::core::cmp::Ordering {
                match *other {
                    Range(ref __self_1_0) => match *self {
                        Range(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Range {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Range(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Range {
            #[inline]
            fn clone(&self) -> Range {
                match *self {
                    Range(ref __self_0_0) => Range(::core::clone::Clone::clone(&(*__self_0_0))),
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Range {
            type GlibType = *mut atspi_sys::AtspiRange;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiRange> for Range {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiRange, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiRange, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiRange {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiRange> for Range {
            type Storage = &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiRange, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiRange, Self> {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *const atspi_sys::AtspiRange>
            for Range
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiRange, Range>>,
                Option<Vec<*const atspi_sys::AtspiRange>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Range],
            ) -> (*mut *const atspi_sys::AtspiRange, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiRange);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiRange,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Range],
            ) -> (*mut *const atspi_sys::AtspiRange, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiRange>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiRange;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Range]) -> *mut *const atspi_sys::AtspiRange {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiRange>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiRange;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *const atspi_sys::AtspiRange>
            for Range
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiRange, Range>>,
                Option<Vec<*const atspi_sys::AtspiRange>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Range],
            ) -> (*const *const atspi_sys::AtspiRange, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiRange,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiRange, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Range],
            ) -> (*const *const atspi_sys::AtspiRange, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/range.rs", 8u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[Range]) -> *const *const atspi_sys::AtspiRange {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/range.rs", 8u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiRange> for Range {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiRange) -> Self {
                Range(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiRange> for Range {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiRange) -> Self {
                Range(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiRange> for Range {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiRange) -> Self {
                Range(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiRange> for Range {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiRange) -> Self {
                Range(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiRange> for Range {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiRange) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiRange)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiRange,
                *mut *mut atspi_sys::AtspiRange,
            > for Range
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRange,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRange,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRange,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiRange,
                *mut *mut atspi_sys::AtspiRange,
            > for Range
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiRange) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRange,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiRange) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiRange> for MemoryManager {
            #[inline]
            unsafe fn copy(ptr: *const atspi_sys::AtspiRange) -> *mut atspi_sys::AtspiRange {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_range_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiRange
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiRange) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_range_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiRange) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/range.rs", 8u32, 1u32),
                    )
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiRange) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/range.rs", 8u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for Range {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_range_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Range {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                ) as *mut atspi_sys::AtspiRange)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Range {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiRange>::to_glib_none(this)
                        .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Range {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiRange>::to_glib_none(
                        &this,
                    )
                    .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
    }
    pub use self::range::Range;
    mod rect {
        use atspi_sys;
        use gobject_sys;
        pub struct Rect(::glib::boxed::Boxed<atspi_sys::AtspiRect, MemoryManager>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Rect {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Rect(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("Rect");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Rect {
            #[inline]
            fn eq(&self, other: &Rect) -> bool {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Rect) -> bool {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Rect {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiRect, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Rect {
            #[inline]
            fn partial_cmp(&self, other: &Rect) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &Rect) -> bool {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &Rect) -> bool {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &Rect) -> bool {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &Rect) -> bool {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Rect {
            #[inline]
            fn cmp(&self, other: &Rect) -> ::core::cmp::Ordering {
                match *other {
                    Rect(ref __self_1_0) => match *self {
                        Rect(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Rect {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Rect(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Rect {
            #[inline]
            fn clone(&self) -> Rect {
                match *self {
                    Rect(ref __self_0_0) => Rect(::core::clone::Clone::clone(&(*__self_0_0))),
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for Rect {
            type GlibType = *mut atspi_sys::AtspiRect;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiRect> for Rect {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiRect, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiRect, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiRect {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiRect> for Rect {
            type Storage = &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiRect, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiRect, Self> {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *mut *const atspi_sys::AtspiRect>
            for Rect
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiRect, Rect>>,
                Option<Vec<*const atspi_sys::AtspiRect>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Rect],
            ) -> (*mut *const atspi_sys::AtspiRect, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiRect);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiRect,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [Rect],
            ) -> (*mut *const atspi_sys::AtspiRect, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiRect>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiRect;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[Rect]) -> *mut *const atspi_sys::AtspiRect {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiRect>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiRect;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibContainerFromSlice<'a, *const *const atspi_sys::AtspiRect>
            for Rect
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiRect, Rect>>,
                Option<Vec<*const atspi_sys::AtspiRect>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [Rect],
            ) -> (*const *const atspi_sys::AtspiRect, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiRect,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiRect, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [Rect],
            ) -> (*const *const atspi_sys::AtspiRect, Self::Storage) {
                {
                    ::std::rt::begin_panic("not yet implemented", &("src/auto/rect.rs", 8u32, 1u32))
                }
            }
            fn to_glib_full_from_slice(_: &[Rect]) -> *const *const atspi_sys::AtspiRect {
                {
                    ::std::rt::begin_panic("not yet implemented", &("src/auto/rect.rs", 8u32, 1u32))
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiRect> for Rect {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiRect) -> Self {
                Rect(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiRect> for Rect {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiRect) -> Self {
                Rect(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiRect> for Rect {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiRect) -> Self {
                Rect(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiRect> for Rect {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiRect) -> Self {
                Rect(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiRect> for Rect {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiRect) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiRect)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiRect,
                *mut *mut atspi_sys::AtspiRect,
            > for Rect
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRect,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRect,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiRect,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiRect,
                *mut *mut atspi_sys::AtspiRect,
            > for Rect
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiRect) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(ptr: *mut *mut atspi_sys::AtspiRect) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiRect) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiRect> for MemoryManager {
            #[inline]
            unsafe fn copy(ptr: *const atspi_sys::AtspiRect) -> *mut atspi_sys::AtspiRect {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_rect_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiRect
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiRect) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_rect_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiRect) {
                {
                    ::std::rt::begin_panic("not yet implemented", &("src/auto/rect.rs", 8u32, 1u32))
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiRect) {
                {
                    ::std::rt::begin_panic("not yet implemented", &("src/auto/rect.rs", 8u32, 1u32))
                }
            }
        }
        impl ::glib::types::StaticType for Rect {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_rect_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for Rect {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                ) as *mut atspi_sys::AtspiRect)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for Rect {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiRect>::to_glib_none(this)
                        .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for Rect {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiRect>::to_glib_none(&this)
                        .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
    }
    pub use self::rect::Rect;
    mod text_range {
        use atspi_sys;
        use gobject_sys;
        pub struct TextRange(::glib::boxed::Boxed<atspi_sys::AtspiTextRange, MemoryManager>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TextRange {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    TextRange(ref __self_0_0) => {
                        let mut debug_trait_builder = f.debug_tuple("TextRange");
                        let _ = debug_trait_builder.field(&&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TextRange {
            #[inline]
            fn eq(&self, other: &TextRange) -> bool {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &TextRange) -> bool {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for TextRange {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<
                        ::glib::boxed::Boxed<atspi_sys::AtspiTextRange, MemoryManager>,
                    >;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for TextRange {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TextRange,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &TextRange) -> bool {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &TextRange) -> bool {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &TextRange) -> bool {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &TextRange) -> bool {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for TextRange {
            #[inline]
            fn cmp(&self, other: &TextRange) -> ::core::cmp::Ordering {
                match *other {
                    TextRange(ref __self_1_0) => match *self {
                        TextRange(ref __self_0_0) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for TextRange {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    TextRange(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TextRange {
            #[inline]
            fn clone(&self) -> TextRange {
                match *self {
                    TextRange(ref __self_0_0) => {
                        TextRange(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::GlibPtrDefault for TextRange {
            type GlibType = *mut atspi_sys::AtspiTextRange;
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtr<'a, *const atspi_sys::AtspiTextRange> for TextRange {
            type Storage = &'a ::glib::boxed::Boxed<atspi_sys::AtspiTextRange, MemoryManager>;
            #[inline]
            fn to_glib_none(
                &'a self,
            ) -> ::glib::translate::Stash<'a, *const atspi_sys::AtspiTextRange, Self> {
                let stash = ::glib::translate::ToGlibPtr::to_glib_none(&self.0);
                ::glib::translate::Stash(stash.0, stash.1)
            }
            #[inline]
            fn to_glib_full(&self) -> *const atspi_sys::AtspiTextRange {
                ::glib::translate::ToGlibPtr::to_glib_full(&self.0)
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::translate::ToGlibPtrMut<'a, *mut atspi_sys::AtspiTextRange> for TextRange {
            type Storage = &'a mut ::glib::boxed::Boxed<atspi_sys::AtspiTextRange, MemoryManager>;
            #[inline]
            fn to_glib_none_mut(
                &'a mut self,
            ) -> ::glib::translate::StashMut<'a, *mut atspi_sys::AtspiTextRange, Self> {
                let stash = ::glib::translate::ToGlibPtrMut::to_glib_none_mut(&mut self.0);
                ::glib::translate::StashMut(stash.0, stash.1)
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *mut *const atspi_sys::AtspiTextRange>
            for TextRange
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiTextRange, TextRange>>,
                Option<Vec<*const atspi_sys::AtspiTextRange>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [TextRange],
            ) -> (*mut *const atspi_sys::AtspiTextRange, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let mut v_ptr: Vec<_> = v.iter().map(|s| s.0).collect();
                v_ptr.push(::std::ptr::null_mut() as *const atspi_sys::AtspiTextRange);
                (
                    v_ptr.as_ptr() as *mut *const atspi_sys::AtspiTextRange,
                    (v, Some(v_ptr)),
                )
            }
            fn to_glib_container_from_slice(
                t: &'a [TextRange],
            ) -> (*mut *const atspi_sys::AtspiTextRange, Self::Storage) {
                let v: Vec<_> = t
                    .iter()
                    .map(|s| ::glib::translate::ToGlibPtr::to_glib_none(s))
                    .collect();
                let v_ptr = unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiTextRange>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiTextRange;
                    for (i, s) in v.iter().enumerate() {
                        ::std::ptr::write(v_ptr.add(i), s.0);
                    }
                    v_ptr
                };
                (v_ptr, (v, None))
            }
            fn to_glib_full_from_slice(t: &[TextRange]) -> *mut *const atspi_sys::AtspiTextRange {
                unsafe {
                    let v_ptr = ::glib::glib_sys::g_malloc0(
                        ::std::mem::size_of::<*const atspi_sys::AtspiTextRange>() * (t.len() + 1),
                    ) as *mut *const atspi_sys::AtspiTextRange;
                    for (i, s) in t.iter().enumerate() {
                        ::std::ptr::write(
                            v_ptr.add(i),
                            ::glib::translate::ToGlibPtr::to_glib_full(s),
                        );
                    }
                    v_ptr
                }
            }
        }
        #[doc(hidden)]
        impl<'a>
            ::glib::translate::ToGlibContainerFromSlice<'a, *const *const atspi_sys::AtspiTextRange>
            for TextRange
        {
            type Storage = (
                Vec<::glib::translate::Stash<'a, *const atspi_sys::AtspiTextRange, TextRange>>,
                Option<Vec<*const atspi_sys::AtspiTextRange>>,
            );
            fn to_glib_none_from_slice(
                t: &'a [TextRange],
            ) -> (*const *const atspi_sys::AtspiTextRange, Self::Storage) {
                let (ptr, stash) = ::glib::translate::ToGlibContainerFromSlice::<
                    'a,
                    *mut *const atspi_sys::AtspiTextRange,
                >::to_glib_none_from_slice(t);
                (ptr as *const *const atspi_sys::AtspiTextRange, stash)
            }
            fn to_glib_container_from_slice(
                _: &'a [TextRange],
            ) -> (*const *const atspi_sys::AtspiTextRange, Self::Storage) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text_range.rs", 8u32, 1u32),
                    )
                }
            }
            fn to_glib_full_from_slice(_: &[TextRange]) -> *const *const atspi_sys::AtspiTextRange {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text_range.rs", 8u32, 1u32),
                    )
                }
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*mut atspi_sys::AtspiTextRange> for TextRange {
            #[inline]
            unsafe fn from_glib_none(ptr: *mut atspi_sys::AtspiTextRange) -> Self {
                TextRange(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrNone<*const atspi_sys::AtspiTextRange> for TextRange {
            #[inline]
            unsafe fn from_glib_none(ptr: *const atspi_sys::AtspiTextRange) -> Self {
                TextRange(::glib::translate::from_glib_none(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrFull<*mut atspi_sys::AtspiTextRange> for TextRange {
            #[inline]
            unsafe fn from_glib_full(ptr: *mut atspi_sys::AtspiTextRange) -> Self {
                TextRange(::glib::translate::from_glib_full(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*mut atspi_sys::AtspiTextRange> for TextRange {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *mut atspi_sys::AtspiTextRange) -> Self {
                TextRange(::glib::translate::from_glib_borrow(ptr))
            }
        }
        #[doc(hidden)]
        impl ::glib::translate::FromGlibPtrBorrow<*const atspi_sys::AtspiTextRange> for TextRange {
            #[inline]
            unsafe fn from_glib_borrow(ptr: *const atspi_sys::AtspiTextRange) -> Self {
                ::glib::translate::from_glib_borrow(ptr as *mut atspi_sys::AtspiTextRange)
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibContainerAsVec<
                *mut atspi_sys::AtspiTextRange,
                *mut *mut atspi_sys::AtspiTextRange,
            > for TextRange
        {
            unsafe fn from_glib_none_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTextRange,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_none(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                res
            }
            unsafe fn from_glib_container_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTextRange,
                num: usize,
            ) -> Vec<Self> {
                let res =
                    ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(ptr, num);
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
            unsafe fn from_glib_full_num_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTextRange,
                num: usize,
            ) -> Vec<Self> {
                if num == 0 || ptr.is_null() {
                    return Vec::new();
                }
                let mut res = Vec::with_capacity(num);
                for i in 0..num {
                    res.push(::glib::translate::from_glib_full(::std::ptr::read(
                        ptr.add(i),
                    )));
                }
                ::glib::glib_sys::g_free(ptr as *mut _);
                res
            }
        }
        #[doc(hidden)]
        impl
            ::glib::translate::FromGlibPtrArrayContainerAsVec<
                *mut atspi_sys::AtspiTextRange,
                *mut *mut atspi_sys::AtspiTextRange,
            > for TextRange
        {
            unsafe fn from_glib_none_as_vec(ptr: *mut *mut atspi_sys::AtspiTextRange) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_none_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_container_as_vec(
                ptr: *mut *mut atspi_sys::AtspiTextRange,
            ) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_container_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
            unsafe fn from_glib_full_as_vec(ptr: *mut *mut atspi_sys::AtspiTextRange) -> Vec<Self> {
                ::glib::translate::FromGlibContainerAsVec::from_glib_full_num_as_vec(
                    ptr,
                    ::glib::translate::c_ptr_array_len(ptr),
                )
            }
        }
        #[doc(hidden)]
        pub struct MemoryManager;
        impl ::glib::boxed::BoxedMemoryManager<atspi_sys::AtspiTextRange> for MemoryManager {
            #[inline]
            unsafe fn copy(
                ptr: *const atspi_sys::AtspiTextRange,
            ) -> *mut atspi_sys::AtspiTextRange {
                gobject_sys::g_boxed_copy(atspi_sys::atspi_text_range_get_type(), ptr as *mut _)
                    as *mut atspi_sys::AtspiTextRange
            }
            #[inline]
            unsafe fn free(ptr: *mut atspi_sys::AtspiTextRange) {
                gobject_sys::g_boxed_free(atspi_sys::atspi_text_range_get_type(), ptr as *mut _)
            }
            #[inline]
            unsafe fn init(_: *mut atspi_sys::AtspiTextRange) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text_range.rs", 8u32, 1u32),
                    )
                }
            }
            #[inline]
            unsafe fn clear(_: *mut atspi_sys::AtspiTextRange) {
                {
                    ::std::rt::begin_panic(
                        "not yet implemented",
                        &("src/auto/text_range.rs", 8u32, 1u32),
                    )
                }
            }
        }
        impl ::glib::types::StaticType for TextRange {
            fn static_type() -> ::glib::types::Type {
                #[allow(unused_unsafe)]
                unsafe {
                    ::glib::translate::from_glib(atspi_sys::atspi_text_range_get_type())
                }
            }
        }
        #[doc(hidden)]
        impl<'a> ::glib::value::FromValueOptional<'a> for TextRange {
            unsafe fn from_value_optional(value: &::glib::Value) -> Option<Self> {
                ::glib::translate::from_glib_full(::glib::gobject_sys::g_value_dup_boxed(
                    ::glib::translate::ToGlibPtr::to_glib_none(value).0,
                )
                    as *mut atspi_sys::AtspiTextRange)
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValue for TextRange {
            unsafe fn set_value(value: &mut ::glib::Value, this: &Self) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiTextRange>::to_glib_none(
                        this,
                    )
                    .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
        #[doc(hidden)]
        impl ::glib::value::SetValueOptional for TextRange {
            unsafe fn set_value_optional(value: &mut ::glib::Value, this: Option<&Self>) {
                ::glib::gobject_sys::g_value_set_boxed(
                    ::glib::translate::ToGlibPtrMut::to_glib_none_mut(value).0,
                    ::glib::translate::ToGlibPtr::<*const atspi_sys::AtspiTextRange>::to_glib_none(
                        &this,
                    )
                    .0 as ::glib::glib_sys::gpointer,
                )
            }
        }
    }
    pub use self::text_range::TextRange;
    mod enums {
        use atspi_sys;
        use glib::translate::*;
        use glib::value::FromValue;
        use glib::value::FromValueOptional;
        use glib::value::SetValue;
        use glib::value::Value;
        use glib::StaticType;
        use glib::Type;
        use gobject_sys;
        use std::fmt;
        pub enum CollectionMatchType {
            Invalid,
            All,
            Any,
            None,
            Empty,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for CollectionMatchType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&CollectionMatchType::Invalid,) => {
                        let mut debug_trait_builder = f.debug_tuple("Invalid");
                        debug_trait_builder.finish()
                    }
                    (&CollectionMatchType::All,) => {
                        let mut debug_trait_builder = f.debug_tuple("All");
                        debug_trait_builder.finish()
                    }
                    (&CollectionMatchType::Any,) => {
                        let mut debug_trait_builder = f.debug_tuple("Any");
                        debug_trait_builder.finish()
                    }
                    (&CollectionMatchType::None,) => {
                        let mut debug_trait_builder = f.debug_tuple("None");
                        debug_trait_builder.finish()
                    }
                    (&CollectionMatchType::Empty,) => {
                        let mut debug_trait_builder = f.debug_tuple("Empty");
                        debug_trait_builder.finish()
                    }
                    (&CollectionMatchType::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&CollectionMatchType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for CollectionMatchType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for CollectionMatchType {
            #[inline]
            fn eq(&self, other: &CollectionMatchType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &CollectionMatchType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for CollectionMatchType {
            #[inline]
            fn cmp(&self, other: &CollectionMatchType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for CollectionMatchType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CollectionMatchType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &CollectionMatchType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &CollectionMatchType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &CollectionMatchType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &CollectionMatchType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionMatchType::__Unknown(ref __self_0),
                                &CollectionMatchType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for CollectionMatchType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&CollectionMatchType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for CollectionMatchType {
            #[inline]
            fn clone(&self) -> CollectionMatchType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for CollectionMatchType {}
        impl fmt::Display for CollectionMatchType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["CollectionMatchType::"],
                    &match (&match *self {
                        CollectionMatchType::Invalid => "Invalid",
                        CollectionMatchType::All => "All",
                        CollectionMatchType::Any => "Any",
                        CollectionMatchType::None => "None",
                        CollectionMatchType::Empty => "Empty",
                        CollectionMatchType::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for CollectionMatchType {
            type GlibType = atspi_sys::AtspiCollectionMatchType;
            fn to_glib(&self) -> atspi_sys::AtspiCollectionMatchType {
                match *self {
                    CollectionMatchType::Invalid => atspi_sys::ATSPI_Collection_MATCH_INVALID,
                    CollectionMatchType::All => atspi_sys::ATSPI_Collection_MATCH_ALL,
                    CollectionMatchType::Any => atspi_sys::ATSPI_Collection_MATCH_ANY,
                    CollectionMatchType::None => atspi_sys::ATSPI_Collection_MATCH_NONE,
                    CollectionMatchType::Empty => atspi_sys::ATSPI_Collection_MATCH_EMPTY,
                    CollectionMatchType::LastDefined => {
                        atspi_sys::ATSPI_Collection_MATCH_LAST_DEFINED
                    }
                    CollectionMatchType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiCollectionMatchType> for CollectionMatchType {
            fn from_glib(value: atspi_sys::AtspiCollectionMatchType) -> Self {
                match value {
                    0 => CollectionMatchType::Invalid,
                    1 => CollectionMatchType::All,
                    2 => CollectionMatchType::Any,
                    3 => CollectionMatchType::None,
                    4 => CollectionMatchType::Empty,
                    5 => CollectionMatchType::LastDefined,
                    value => CollectionMatchType::__Unknown(value),
                }
            }
        }
        impl StaticType for CollectionMatchType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_collection_match_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for CollectionMatchType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for CollectionMatchType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for CollectionMatchType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum CollectionSortOrder {
            Invalid,
            Canonical,
            Flow,
            Tab,
            ReverseCanonical,
            ReverseFlow,
            ReverseTab,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for CollectionSortOrder {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&CollectionSortOrder::Invalid,) => {
                        let mut debug_trait_builder = f.debug_tuple("Invalid");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::Canonical,) => {
                        let mut debug_trait_builder = f.debug_tuple("Canonical");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::Flow,) => {
                        let mut debug_trait_builder = f.debug_tuple("Flow");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::Tab,) => {
                        let mut debug_trait_builder = f.debug_tuple("Tab");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::ReverseCanonical,) => {
                        let mut debug_trait_builder = f.debug_tuple("ReverseCanonical");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::ReverseFlow,) => {
                        let mut debug_trait_builder = f.debug_tuple("ReverseFlow");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::ReverseTab,) => {
                        let mut debug_trait_builder = f.debug_tuple("ReverseTab");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&CollectionSortOrder::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for CollectionSortOrder {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for CollectionSortOrder {
            #[inline]
            fn eq(&self, other: &CollectionSortOrder) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &CollectionSortOrder) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for CollectionSortOrder {
            #[inline]
            fn cmp(&self, other: &CollectionSortOrder) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for CollectionSortOrder {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CollectionSortOrder,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &CollectionSortOrder) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &CollectionSortOrder) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &CollectionSortOrder) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &CollectionSortOrder) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionSortOrder::__Unknown(ref __self_0),
                                &CollectionSortOrder::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for CollectionSortOrder {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&CollectionSortOrder::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for CollectionSortOrder {
            #[inline]
            fn clone(&self) -> CollectionSortOrder {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for CollectionSortOrder {}
        impl fmt::Display for CollectionSortOrder {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["CollectionSortOrder::"],
                    &match (&match *self {
                        CollectionSortOrder::Invalid => "Invalid",
                        CollectionSortOrder::Canonical => "Canonical",
                        CollectionSortOrder::Flow => "Flow",
                        CollectionSortOrder::Tab => "Tab",
                        CollectionSortOrder::ReverseCanonical => "ReverseCanonical",
                        CollectionSortOrder::ReverseFlow => "ReverseFlow",
                        CollectionSortOrder::ReverseTab => "ReverseTab",
                        CollectionSortOrder::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for CollectionSortOrder {
            type GlibType = atspi_sys::AtspiCollectionSortOrder;
            fn to_glib(&self) -> atspi_sys::AtspiCollectionSortOrder {
                match *self {
                    CollectionSortOrder::Invalid => atspi_sys::ATSPI_Collection_SORT_ORDER_INVALID,
                    CollectionSortOrder::Canonical => {
                        atspi_sys::ATSPI_Collection_SORT_ORDER_CANONICAL
                    }
                    CollectionSortOrder::Flow => atspi_sys::ATSPI_Collection_SORT_ORDER_FLOW,
                    CollectionSortOrder::Tab => atspi_sys::ATSPI_Collection_SORT_ORDER_TAB,
                    CollectionSortOrder::ReverseCanonical => {
                        atspi_sys::ATSPI_Collection_SORT_ORDER_REVERSE_CANONICAL
                    }
                    CollectionSortOrder::ReverseFlow => {
                        atspi_sys::ATSPI_Collection_SORT_ORDER_REVERSE_FLOW
                    }
                    CollectionSortOrder::ReverseTab => {
                        atspi_sys::ATSPI_Collection_SORT_ORDER_REVERSE_TAB
                    }
                    CollectionSortOrder::LastDefined => {
                        atspi_sys::ATSPI_Collection_SORT_ORDER_LAST_DEFINED
                    }
                    CollectionSortOrder::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiCollectionSortOrder> for CollectionSortOrder {
            fn from_glib(value: atspi_sys::AtspiCollectionSortOrder) -> Self {
                match value {
                    0 => CollectionSortOrder::Invalid,
                    1 => CollectionSortOrder::Canonical,
                    2 => CollectionSortOrder::Flow,
                    3 => CollectionSortOrder::Tab,
                    4 => CollectionSortOrder::ReverseCanonical,
                    5 => CollectionSortOrder::ReverseFlow,
                    6 => CollectionSortOrder::ReverseTab,
                    7 => CollectionSortOrder::LastDefined,
                    value => CollectionSortOrder::__Unknown(value),
                }
            }
        }
        impl StaticType for CollectionSortOrder {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_collection_sort_order_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for CollectionSortOrder {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for CollectionSortOrder {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for CollectionSortOrder {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum CollectionTreeTraversalType {
            RestrictChildren,
            RestrictSibling,
            Inorder,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for CollectionTreeTraversalType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&CollectionTreeTraversalType::RestrictChildren,) => {
                        let mut debug_trait_builder = f.debug_tuple("RestrictChildren");
                        debug_trait_builder.finish()
                    }
                    (&CollectionTreeTraversalType::RestrictSibling,) => {
                        let mut debug_trait_builder = f.debug_tuple("RestrictSibling");
                        debug_trait_builder.finish()
                    }
                    (&CollectionTreeTraversalType::Inorder,) => {
                        let mut debug_trait_builder = f.debug_tuple("Inorder");
                        debug_trait_builder.finish()
                    }
                    (&CollectionTreeTraversalType::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&CollectionTreeTraversalType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for CollectionTreeTraversalType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for CollectionTreeTraversalType {
            #[inline]
            fn eq(&self, other: &CollectionTreeTraversalType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &CollectionTreeTraversalType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for CollectionTreeTraversalType {
            #[inline]
            fn cmp(&self, other: &CollectionTreeTraversalType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for CollectionTreeTraversalType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CollectionTreeTraversalType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &CollectionTreeTraversalType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &CollectionTreeTraversalType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &CollectionTreeTraversalType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &CollectionTreeTraversalType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CollectionTreeTraversalType::__Unknown(ref __self_0),
                                &CollectionTreeTraversalType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for CollectionTreeTraversalType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&CollectionTreeTraversalType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for CollectionTreeTraversalType {
            #[inline]
            fn clone(&self) -> CollectionTreeTraversalType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for CollectionTreeTraversalType {}
        impl fmt::Display for CollectionTreeTraversalType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["CollectionTreeTraversalType::"],
                    &match (&match *self {
                        CollectionTreeTraversalType::RestrictChildren => "RestrictChildren",
                        CollectionTreeTraversalType::RestrictSibling => "RestrictSibling",
                        CollectionTreeTraversalType::Inorder => "Inorder",
                        CollectionTreeTraversalType::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for CollectionTreeTraversalType {
            type GlibType = atspi_sys::AtspiCollectionTreeTraversalType;
            fn to_glib(&self) -> atspi_sys::AtspiCollectionTreeTraversalType {
                match *self {
                    CollectionTreeTraversalType::RestrictChildren => {
                        atspi_sys::ATSPI_Collection_TREE_RESTRICT_CHILDREN
                    }
                    CollectionTreeTraversalType::RestrictSibling => {
                        atspi_sys::ATSPI_Collection_TREE_RESTRICT_SIBLING
                    }
                    CollectionTreeTraversalType::Inorder => {
                        atspi_sys::ATSPI_Collection_TREE_INORDER
                    }
                    CollectionTreeTraversalType::LastDefined => {
                        atspi_sys::ATSPI_Collection_TREE_LAST_DEFINED
                    }
                    CollectionTreeTraversalType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiCollectionTreeTraversalType> for CollectionTreeTraversalType {
            fn from_glib(value: atspi_sys::AtspiCollectionTreeTraversalType) -> Self {
                match value {
                    0 => CollectionTreeTraversalType::RestrictChildren,
                    1 => CollectionTreeTraversalType::RestrictSibling,
                    2 => CollectionTreeTraversalType::Inorder,
                    3 => CollectionTreeTraversalType::LastDefined,
                    value => CollectionTreeTraversalType::__Unknown(value),
                }
            }
        }
        impl StaticType for CollectionTreeTraversalType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_collection_tree_traversal_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for CollectionTreeTraversalType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for CollectionTreeTraversalType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for CollectionTreeTraversalType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum ComponentLayer {
            Invalid,
            Background,
            Canvas,
            Widget,
            Mdi,
            Popup,
            Overlay,
            Window,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ComponentLayer {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ComponentLayer::Invalid,) => {
                        let mut debug_trait_builder = f.debug_tuple("Invalid");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Background,) => {
                        let mut debug_trait_builder = f.debug_tuple("Background");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Canvas,) => {
                        let mut debug_trait_builder = f.debug_tuple("Canvas");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Widget,) => {
                        let mut debug_trait_builder = f.debug_tuple("Widget");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Mdi,) => {
                        let mut debug_trait_builder = f.debug_tuple("Mdi");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Popup,) => {
                        let mut debug_trait_builder = f.debug_tuple("Popup");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Overlay,) => {
                        let mut debug_trait_builder = f.debug_tuple("Overlay");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::Window,) => {
                        let mut debug_trait_builder = f.debug_tuple("Window");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&ComponentLayer::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ComponentLayer {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ComponentLayer {
            #[inline]
            fn eq(&self, other: &ComponentLayer) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &ComponentLayer) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for ComponentLayer {
            #[inline]
            fn cmp(&self, other: &ComponentLayer) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for ComponentLayer {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ComponentLayer,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &ComponentLayer) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &ComponentLayer) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &ComponentLayer) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &ComponentLayer) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &ComponentLayer::__Unknown(ref __self_0),
                                &ComponentLayer::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for ComponentLayer {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&ComponentLayer::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ComponentLayer {
            #[inline]
            fn clone(&self) -> ComponentLayer {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for ComponentLayer {}
        impl fmt::Display for ComponentLayer {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["ComponentLayer::"],
                    &match (&match *self {
                        ComponentLayer::Invalid => "Invalid",
                        ComponentLayer::Background => "Background",
                        ComponentLayer::Canvas => "Canvas",
                        ComponentLayer::Widget => "Widget",
                        ComponentLayer::Mdi => "Mdi",
                        ComponentLayer::Popup => "Popup",
                        ComponentLayer::Overlay => "Overlay",
                        ComponentLayer::Window => "Window",
                        ComponentLayer::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for ComponentLayer {
            type GlibType = atspi_sys::AtspiComponentLayer;
            fn to_glib(&self) -> atspi_sys::AtspiComponentLayer {
                match *self {
                    ComponentLayer::Invalid => atspi_sys::ATSPI_LAYER_INVALID,
                    ComponentLayer::Background => atspi_sys::ATSPI_LAYER_BACKGROUND,
                    ComponentLayer::Canvas => atspi_sys::ATSPI_LAYER_CANVAS,
                    ComponentLayer::Widget => atspi_sys::ATSPI_LAYER_WIDGET,
                    ComponentLayer::Mdi => atspi_sys::ATSPI_LAYER_MDI,
                    ComponentLayer::Popup => atspi_sys::ATSPI_LAYER_POPUP,
                    ComponentLayer::Overlay => atspi_sys::ATSPI_LAYER_OVERLAY,
                    ComponentLayer::Window => atspi_sys::ATSPI_LAYER_WINDOW,
                    ComponentLayer::LastDefined => atspi_sys::ATSPI_LAYER_LAST_DEFINED,
                    ComponentLayer::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiComponentLayer> for ComponentLayer {
            fn from_glib(value: atspi_sys::AtspiComponentLayer) -> Self {
                match value {
                    0 => ComponentLayer::Invalid,
                    1 => ComponentLayer::Background,
                    2 => ComponentLayer::Canvas,
                    3 => ComponentLayer::Widget,
                    4 => ComponentLayer::Mdi,
                    5 => ComponentLayer::Popup,
                    6 => ComponentLayer::Overlay,
                    7 => ComponentLayer::Window,
                    8 => ComponentLayer::LastDefined,
                    value => ComponentLayer::__Unknown(value),
                }
            }
        }
        impl StaticType for ComponentLayer {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_component_layer_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for ComponentLayer {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for ComponentLayer {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for ComponentLayer {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum CoordType {
            Screen,
            Window,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for CoordType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&CoordType::Screen,) => {
                        let mut debug_trait_builder = f.debug_tuple("Screen");
                        debug_trait_builder.finish()
                    }
                    (&CoordType::Window,) => {
                        let mut debug_trait_builder = f.debug_tuple("Window");
                        debug_trait_builder.finish()
                    }
                    (&CoordType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for CoordType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for CoordType {
            #[inline]
            fn eq(&self, other: &CoordType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &CoordType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for CoordType {
            #[inline]
            fn cmp(&self, other: &CoordType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for CoordType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CoordType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &CoordType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &CoordType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &CoordType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &CoordType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &CoordType::__Unknown(ref __self_0),
                                &CoordType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for CoordType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&CoordType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for CoordType {
            #[inline]
            fn clone(&self) -> CoordType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for CoordType {}
        impl fmt::Display for CoordType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["CoordType::"],
                    &match (&match *self {
                        CoordType::Screen => "Screen",
                        CoordType::Window => "Window",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for CoordType {
            type GlibType = atspi_sys::AtspiCoordType;
            fn to_glib(&self) -> atspi_sys::AtspiCoordType {
                match *self {
                    CoordType::Screen => atspi_sys::ATSPI_COORD_TYPE_SCREEN,
                    CoordType::Window => atspi_sys::ATSPI_COORD_TYPE_WINDOW,
                    CoordType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiCoordType> for CoordType {
            fn from_glib(value: atspi_sys::AtspiCoordType) -> Self {
                match value {
                    0 => CoordType::Screen,
                    1 => CoordType::Window,
                    value => CoordType::__Unknown(value),
                }
            }
        }
        impl StaticType for CoordType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_coord_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for CoordType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for CoordType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for CoordType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum KeySynthType {
            Press,
            Release,
            Pressrelease,
            Sym,
            String,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for KeySynthType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&KeySynthType::Press,) => {
                        let mut debug_trait_builder = f.debug_tuple("Press");
                        debug_trait_builder.finish()
                    }
                    (&KeySynthType::Release,) => {
                        let mut debug_trait_builder = f.debug_tuple("Release");
                        debug_trait_builder.finish()
                    }
                    (&KeySynthType::Pressrelease,) => {
                        let mut debug_trait_builder = f.debug_tuple("Pressrelease");
                        debug_trait_builder.finish()
                    }
                    (&KeySynthType::Sym,) => {
                        let mut debug_trait_builder = f.debug_tuple("Sym");
                        debug_trait_builder.finish()
                    }
                    (&KeySynthType::String,) => {
                        let mut debug_trait_builder = f.debug_tuple("String");
                        debug_trait_builder.finish()
                    }
                    (&KeySynthType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for KeySynthType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for KeySynthType {
            #[inline]
            fn eq(&self, other: &KeySynthType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &KeySynthType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for KeySynthType {
            #[inline]
            fn cmp(&self, other: &KeySynthType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for KeySynthType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &KeySynthType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &KeySynthType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &KeySynthType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &KeySynthType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &KeySynthType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &KeySynthType::__Unknown(ref __self_0),
                                &KeySynthType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for KeySynthType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&KeySynthType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for KeySynthType {
            #[inline]
            fn clone(&self) -> KeySynthType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for KeySynthType {}
        impl fmt::Display for KeySynthType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["KeySynthType::"],
                    &match (&match *self {
                        KeySynthType::Press => "Press",
                        KeySynthType::Release => "Release",
                        KeySynthType::Pressrelease => "Pressrelease",
                        KeySynthType::Sym => "Sym",
                        KeySynthType::String => "String",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for KeySynthType {
            type GlibType = atspi_sys::AtspiKeySynthType;
            fn to_glib(&self) -> atspi_sys::AtspiKeySynthType {
                match *self {
                    KeySynthType::Press => atspi_sys::ATSPI_KEY_PRESS,
                    KeySynthType::Release => atspi_sys::ATSPI_KEY_RELEASE,
                    KeySynthType::Pressrelease => atspi_sys::ATSPI_KEY_PRESSRELEASE,
                    KeySynthType::Sym => atspi_sys::ATSPI_KEY_SYM,
                    KeySynthType::String => atspi_sys::ATSPI_KEY_STRING,
                    KeySynthType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiKeySynthType> for KeySynthType {
            fn from_glib(value: atspi_sys::AtspiKeySynthType) -> Self {
                match value {
                    0 => KeySynthType::Press,
                    1 => KeySynthType::Release,
                    2 => KeySynthType::Pressrelease,
                    3 => KeySynthType::Sym,
                    4 => KeySynthType::String,
                    value => KeySynthType::__Unknown(value),
                }
            }
        }
        impl StaticType for KeySynthType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_key_synth_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for KeySynthType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for KeySynthType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for KeySynthType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum RelationType {
            Null,
            LabelFor,
            LabelledBy,
            ControllerFor,
            ControlledBy,
            MemberOf,
            TooltipFor,
            NodeChildOf,
            NodeParentOf,
            Extended,
            FlowsTo,
            FlowsFrom,
            SubwindowOf,
            Embeds,
            EmbeddedBy,
            PopupFor,
            ParentWindowOf,
            DescriptionFor,
            DescribedBy,
            Details,
            DetailsFor,
            ErrorMessage,
            ErrorFor,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for RelationType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&RelationType::Null,) => {
                        let mut debug_trait_builder = f.debug_tuple("Null");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::LabelFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("LabelFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::LabelledBy,) => {
                        let mut debug_trait_builder = f.debug_tuple("LabelledBy");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::ControllerFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("ControllerFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::ControlledBy,) => {
                        let mut debug_trait_builder = f.debug_tuple("ControlledBy");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::MemberOf,) => {
                        let mut debug_trait_builder = f.debug_tuple("MemberOf");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::TooltipFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("TooltipFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::NodeChildOf,) => {
                        let mut debug_trait_builder = f.debug_tuple("NodeChildOf");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::NodeParentOf,) => {
                        let mut debug_trait_builder = f.debug_tuple("NodeParentOf");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::Extended,) => {
                        let mut debug_trait_builder = f.debug_tuple("Extended");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::FlowsTo,) => {
                        let mut debug_trait_builder = f.debug_tuple("FlowsTo");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::FlowsFrom,) => {
                        let mut debug_trait_builder = f.debug_tuple("FlowsFrom");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::SubwindowOf,) => {
                        let mut debug_trait_builder = f.debug_tuple("SubwindowOf");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::Embeds,) => {
                        let mut debug_trait_builder = f.debug_tuple("Embeds");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::EmbeddedBy,) => {
                        let mut debug_trait_builder = f.debug_tuple("EmbeddedBy");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::PopupFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("PopupFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::ParentWindowOf,) => {
                        let mut debug_trait_builder = f.debug_tuple("ParentWindowOf");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::DescriptionFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("DescriptionFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::DescribedBy,) => {
                        let mut debug_trait_builder = f.debug_tuple("DescribedBy");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::Details,) => {
                        let mut debug_trait_builder = f.debug_tuple("Details");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::DetailsFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("DetailsFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::ErrorMessage,) => {
                        let mut debug_trait_builder = f.debug_tuple("ErrorMessage");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::ErrorFor,) => {
                        let mut debug_trait_builder = f.debug_tuple("ErrorFor");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&RelationType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for RelationType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for RelationType {
            #[inline]
            fn eq(&self, other: &RelationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &RelationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for RelationType {
            #[inline]
            fn cmp(&self, other: &RelationType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for RelationType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &RelationType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &RelationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &RelationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &RelationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &RelationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &RelationType::__Unknown(ref __self_0),
                                &RelationType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for RelationType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&RelationType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for RelationType {
            #[inline]
            fn clone(&self) -> RelationType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for RelationType {}
        impl fmt::Display for RelationType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["RelationType::"],
                    &match (&match *self {
                        RelationType::Null => "Null",
                        RelationType::LabelFor => "LabelFor",
                        RelationType::LabelledBy => "LabelledBy",
                        RelationType::ControllerFor => "ControllerFor",
                        RelationType::ControlledBy => "ControlledBy",
                        RelationType::MemberOf => "MemberOf",
                        RelationType::TooltipFor => "TooltipFor",
                        RelationType::NodeChildOf => "NodeChildOf",
                        RelationType::NodeParentOf => "NodeParentOf",
                        RelationType::Extended => "Extended",
                        RelationType::FlowsTo => "FlowsTo",
                        RelationType::FlowsFrom => "FlowsFrom",
                        RelationType::SubwindowOf => "SubwindowOf",
                        RelationType::Embeds => "Embeds",
                        RelationType::EmbeddedBy => "EmbeddedBy",
                        RelationType::PopupFor => "PopupFor",
                        RelationType::ParentWindowOf => "ParentWindowOf",
                        RelationType::DescriptionFor => "DescriptionFor",
                        RelationType::DescribedBy => "DescribedBy",
                        RelationType::Details => "Details",
                        RelationType::DetailsFor => "DetailsFor",
                        RelationType::ErrorMessage => "ErrorMessage",
                        RelationType::ErrorFor => "ErrorFor",
                        RelationType::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for RelationType {
            type GlibType = atspi_sys::AtspiRelationType;
            fn to_glib(&self) -> atspi_sys::AtspiRelationType {
                match *self {
                    RelationType::Null => atspi_sys::ATSPI_RELATION_NULL,
                    RelationType::LabelFor => atspi_sys::ATSPI_RELATION_LABEL_FOR,
                    RelationType::LabelledBy => atspi_sys::ATSPI_RELATION_LABELLED_BY,
                    RelationType::ControllerFor => atspi_sys::ATSPI_RELATION_CONTROLLER_FOR,
                    RelationType::ControlledBy => atspi_sys::ATSPI_RELATION_CONTROLLED_BY,
                    RelationType::MemberOf => atspi_sys::ATSPI_RELATION_MEMBER_OF,
                    RelationType::TooltipFor => atspi_sys::ATSPI_RELATION_TOOLTIP_FOR,
                    RelationType::NodeChildOf => atspi_sys::ATSPI_RELATION_NODE_CHILD_OF,
                    RelationType::NodeParentOf => atspi_sys::ATSPI_RELATION_NODE_PARENT_OF,
                    RelationType::Extended => atspi_sys::ATSPI_RELATION_EXTENDED,
                    RelationType::FlowsTo => atspi_sys::ATSPI_RELATION_FLOWS_TO,
                    RelationType::FlowsFrom => atspi_sys::ATSPI_RELATION_FLOWS_FROM,
                    RelationType::SubwindowOf => atspi_sys::ATSPI_RELATION_SUBWINDOW_OF,
                    RelationType::Embeds => atspi_sys::ATSPI_RELATION_EMBEDS,
                    RelationType::EmbeddedBy => atspi_sys::ATSPI_RELATION_EMBEDDED_BY,
                    RelationType::PopupFor => atspi_sys::ATSPI_RELATION_POPUP_FOR,
                    RelationType::ParentWindowOf => atspi_sys::ATSPI_RELATION_PARENT_WINDOW_OF,
                    RelationType::DescriptionFor => atspi_sys::ATSPI_RELATION_DESCRIPTION_FOR,
                    RelationType::DescribedBy => atspi_sys::ATSPI_RELATION_DESCRIBED_BY,
                    RelationType::Details => atspi_sys::ATSPI_RELATION_DETAILS,
                    RelationType::DetailsFor => atspi_sys::ATSPI_RELATION_DETAILS_FOR,
                    RelationType::ErrorMessage => atspi_sys::ATSPI_RELATION_ERROR_MESSAGE,
                    RelationType::ErrorFor => atspi_sys::ATSPI_RELATION_ERROR_FOR,
                    RelationType::LastDefined => atspi_sys::ATSPI_RELATION_LAST_DEFINED,
                    RelationType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiRelationType> for RelationType {
            fn from_glib(value: atspi_sys::AtspiRelationType) -> Self {
                match value {
                    0 => RelationType::Null,
                    1 => RelationType::LabelFor,
                    2 => RelationType::LabelledBy,
                    3 => RelationType::ControllerFor,
                    4 => RelationType::ControlledBy,
                    5 => RelationType::MemberOf,
                    6 => RelationType::TooltipFor,
                    7 => RelationType::NodeChildOf,
                    8 => RelationType::NodeParentOf,
                    9 => RelationType::Extended,
                    10 => RelationType::FlowsTo,
                    11 => RelationType::FlowsFrom,
                    12 => RelationType::SubwindowOf,
                    13 => RelationType::Embeds,
                    14 => RelationType::EmbeddedBy,
                    15 => RelationType::PopupFor,
                    16 => RelationType::ParentWindowOf,
                    17 => RelationType::DescriptionFor,
                    18 => RelationType::DescribedBy,
                    19 => RelationType::Details,
                    20 => RelationType::DetailsFor,
                    21 => RelationType::ErrorMessage,
                    22 => RelationType::ErrorFor,
                    23 => RelationType::LastDefined,
                    value => RelationType::__Unknown(value),
                }
            }
        }
        impl StaticType for RelationType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_relation_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for RelationType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for RelationType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for RelationType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum Role {
            Invalid,
            AcceleratorLabel,
            Alert,
            Animation,
            Arrow,
            Calendar,
            Canvas,
            CheckBox,
            CheckMenuItem,
            ColorChooser,
            ColumnHeader,
            ComboBox,
            DateEditor,
            DesktopIcon,
            DesktopFrame,
            Dial,
            Dialog,
            DirectoryPane,
            DrawingArea,
            FileChooser,
            Filler,
            FocusTraversable,
            FontChooser,
            Frame,
            GlassPane,
            HtmlContainer,
            Icon,
            Image,
            InternalFrame,
            Label,
            LayeredPane,
            List,
            ListItem,
            Menu,
            MenuBar,
            MenuItem,
            OptionPane,
            PageTab,
            PageTabList,
            Panel,
            PasswordText,
            PopupMenu,
            ProgressBar,
            PushButton,
            RadioButton,
            RadioMenuItem,
            RootPane,
            RowHeader,
            ScrollBar,
            ScrollPane,
            Separator,
            Slider,
            SpinButton,
            SplitPane,
            StatusBar,
            Table,
            TableCell,
            TableColumnHeader,
            TableRowHeader,
            TearoffMenuItem,
            Terminal,
            Text,
            ToggleButton,
            ToolBar,
            ToolTip,
            Tree,
            TreeTable,
            Unknown,
            Viewport,
            Window,
            Extended,
            Header,
            Footer,
            Paragraph,
            Ruler,
            Application,
            Autocomplete,
            Editbar,
            Embedded,
            Entry,
            Chart,
            Caption,
            DocumentFrame,
            Heading,
            Page,
            Section,
            RedundantObject,
            Form,
            Link,
            InputMethodWindow,
            TableRow,
            TreeItem,
            DocumentSpreadsheet,
            DocumentPresentation,
            DocumentText,
            DocumentWeb,
            DocumentEmail,
            Comment,
            ListBox,
            Grouping,
            ImageMap,
            Notification,
            InfoBar,
            LevelBar,
            TitleBar,
            BlockQuote,
            Audio,
            Video,
            Definition,
            Article,
            Landmark,
            Log,
            Marquee,
            Math,
            Rating,
            Timer,
            Static,
            MathFraction,
            MathRoot,
            Subscript,
            Superscript,
            DescriptionList,
            DescriptionTerm,
            DescriptionValue,
            Footnote,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Role {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&Role::Invalid,) => {
                        let mut debug_trait_builder = f.debug_tuple("Invalid");
                        debug_trait_builder.finish()
                    }
                    (&Role::AcceleratorLabel,) => {
                        let mut debug_trait_builder = f.debug_tuple("AcceleratorLabel");
                        debug_trait_builder.finish()
                    }
                    (&Role::Alert,) => {
                        let mut debug_trait_builder = f.debug_tuple("Alert");
                        debug_trait_builder.finish()
                    }
                    (&Role::Animation,) => {
                        let mut debug_trait_builder = f.debug_tuple("Animation");
                        debug_trait_builder.finish()
                    }
                    (&Role::Arrow,) => {
                        let mut debug_trait_builder = f.debug_tuple("Arrow");
                        debug_trait_builder.finish()
                    }
                    (&Role::Calendar,) => {
                        let mut debug_trait_builder = f.debug_tuple("Calendar");
                        debug_trait_builder.finish()
                    }
                    (&Role::Canvas,) => {
                        let mut debug_trait_builder = f.debug_tuple("Canvas");
                        debug_trait_builder.finish()
                    }
                    (&Role::CheckBox,) => {
                        let mut debug_trait_builder = f.debug_tuple("CheckBox");
                        debug_trait_builder.finish()
                    }
                    (&Role::CheckMenuItem,) => {
                        let mut debug_trait_builder = f.debug_tuple("CheckMenuItem");
                        debug_trait_builder.finish()
                    }
                    (&Role::ColorChooser,) => {
                        let mut debug_trait_builder = f.debug_tuple("ColorChooser");
                        debug_trait_builder.finish()
                    }
                    (&Role::ColumnHeader,) => {
                        let mut debug_trait_builder = f.debug_tuple("ColumnHeader");
                        debug_trait_builder.finish()
                    }
                    (&Role::ComboBox,) => {
                        let mut debug_trait_builder = f.debug_tuple("ComboBox");
                        debug_trait_builder.finish()
                    }
                    (&Role::DateEditor,) => {
                        let mut debug_trait_builder = f.debug_tuple("DateEditor");
                        debug_trait_builder.finish()
                    }
                    (&Role::DesktopIcon,) => {
                        let mut debug_trait_builder = f.debug_tuple("DesktopIcon");
                        debug_trait_builder.finish()
                    }
                    (&Role::DesktopFrame,) => {
                        let mut debug_trait_builder = f.debug_tuple("DesktopFrame");
                        debug_trait_builder.finish()
                    }
                    (&Role::Dial,) => {
                        let mut debug_trait_builder = f.debug_tuple("Dial");
                        debug_trait_builder.finish()
                    }
                    (&Role::Dialog,) => {
                        let mut debug_trait_builder = f.debug_tuple("Dialog");
                        debug_trait_builder.finish()
                    }
                    (&Role::DirectoryPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("DirectoryPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::DrawingArea,) => {
                        let mut debug_trait_builder = f.debug_tuple("DrawingArea");
                        debug_trait_builder.finish()
                    }
                    (&Role::FileChooser,) => {
                        let mut debug_trait_builder = f.debug_tuple("FileChooser");
                        debug_trait_builder.finish()
                    }
                    (&Role::Filler,) => {
                        let mut debug_trait_builder = f.debug_tuple("Filler");
                        debug_trait_builder.finish()
                    }
                    (&Role::FocusTraversable,) => {
                        let mut debug_trait_builder = f.debug_tuple("FocusTraversable");
                        debug_trait_builder.finish()
                    }
                    (&Role::FontChooser,) => {
                        let mut debug_trait_builder = f.debug_tuple("FontChooser");
                        debug_trait_builder.finish()
                    }
                    (&Role::Frame,) => {
                        let mut debug_trait_builder = f.debug_tuple("Frame");
                        debug_trait_builder.finish()
                    }
                    (&Role::GlassPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("GlassPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::HtmlContainer,) => {
                        let mut debug_trait_builder = f.debug_tuple("HtmlContainer");
                        debug_trait_builder.finish()
                    }
                    (&Role::Icon,) => {
                        let mut debug_trait_builder = f.debug_tuple("Icon");
                        debug_trait_builder.finish()
                    }
                    (&Role::Image,) => {
                        let mut debug_trait_builder = f.debug_tuple("Image");
                        debug_trait_builder.finish()
                    }
                    (&Role::InternalFrame,) => {
                        let mut debug_trait_builder = f.debug_tuple("InternalFrame");
                        debug_trait_builder.finish()
                    }
                    (&Role::Label,) => {
                        let mut debug_trait_builder = f.debug_tuple("Label");
                        debug_trait_builder.finish()
                    }
                    (&Role::LayeredPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("LayeredPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::List,) => {
                        let mut debug_trait_builder = f.debug_tuple("List");
                        debug_trait_builder.finish()
                    }
                    (&Role::ListItem,) => {
                        let mut debug_trait_builder = f.debug_tuple("ListItem");
                        debug_trait_builder.finish()
                    }
                    (&Role::Menu,) => {
                        let mut debug_trait_builder = f.debug_tuple("Menu");
                        debug_trait_builder.finish()
                    }
                    (&Role::MenuBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("MenuBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::MenuItem,) => {
                        let mut debug_trait_builder = f.debug_tuple("MenuItem");
                        debug_trait_builder.finish()
                    }
                    (&Role::OptionPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("OptionPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::PageTab,) => {
                        let mut debug_trait_builder = f.debug_tuple("PageTab");
                        debug_trait_builder.finish()
                    }
                    (&Role::PageTabList,) => {
                        let mut debug_trait_builder = f.debug_tuple("PageTabList");
                        debug_trait_builder.finish()
                    }
                    (&Role::Panel,) => {
                        let mut debug_trait_builder = f.debug_tuple("Panel");
                        debug_trait_builder.finish()
                    }
                    (&Role::PasswordText,) => {
                        let mut debug_trait_builder = f.debug_tuple("PasswordText");
                        debug_trait_builder.finish()
                    }
                    (&Role::PopupMenu,) => {
                        let mut debug_trait_builder = f.debug_tuple("PopupMenu");
                        debug_trait_builder.finish()
                    }
                    (&Role::ProgressBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("ProgressBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::PushButton,) => {
                        let mut debug_trait_builder = f.debug_tuple("PushButton");
                        debug_trait_builder.finish()
                    }
                    (&Role::RadioButton,) => {
                        let mut debug_trait_builder = f.debug_tuple("RadioButton");
                        debug_trait_builder.finish()
                    }
                    (&Role::RadioMenuItem,) => {
                        let mut debug_trait_builder = f.debug_tuple("RadioMenuItem");
                        debug_trait_builder.finish()
                    }
                    (&Role::RootPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("RootPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::RowHeader,) => {
                        let mut debug_trait_builder = f.debug_tuple("RowHeader");
                        debug_trait_builder.finish()
                    }
                    (&Role::ScrollBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("ScrollBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::ScrollPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("ScrollPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::Separator,) => {
                        let mut debug_trait_builder = f.debug_tuple("Separator");
                        debug_trait_builder.finish()
                    }
                    (&Role::Slider,) => {
                        let mut debug_trait_builder = f.debug_tuple("Slider");
                        debug_trait_builder.finish()
                    }
                    (&Role::SpinButton,) => {
                        let mut debug_trait_builder = f.debug_tuple("SpinButton");
                        debug_trait_builder.finish()
                    }
                    (&Role::SplitPane,) => {
                        let mut debug_trait_builder = f.debug_tuple("SplitPane");
                        debug_trait_builder.finish()
                    }
                    (&Role::StatusBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("StatusBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::Table,) => {
                        let mut debug_trait_builder = f.debug_tuple("Table");
                        debug_trait_builder.finish()
                    }
                    (&Role::TableCell,) => {
                        let mut debug_trait_builder = f.debug_tuple("TableCell");
                        debug_trait_builder.finish()
                    }
                    (&Role::TableColumnHeader,) => {
                        let mut debug_trait_builder = f.debug_tuple("TableColumnHeader");
                        debug_trait_builder.finish()
                    }
                    (&Role::TableRowHeader,) => {
                        let mut debug_trait_builder = f.debug_tuple("TableRowHeader");
                        debug_trait_builder.finish()
                    }
                    (&Role::TearoffMenuItem,) => {
                        let mut debug_trait_builder = f.debug_tuple("TearoffMenuItem");
                        debug_trait_builder.finish()
                    }
                    (&Role::Terminal,) => {
                        let mut debug_trait_builder = f.debug_tuple("Terminal");
                        debug_trait_builder.finish()
                    }
                    (&Role::Text,) => {
                        let mut debug_trait_builder = f.debug_tuple("Text");
                        debug_trait_builder.finish()
                    }
                    (&Role::ToggleButton,) => {
                        let mut debug_trait_builder = f.debug_tuple("ToggleButton");
                        debug_trait_builder.finish()
                    }
                    (&Role::ToolBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("ToolBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::ToolTip,) => {
                        let mut debug_trait_builder = f.debug_tuple("ToolTip");
                        debug_trait_builder.finish()
                    }
                    (&Role::Tree,) => {
                        let mut debug_trait_builder = f.debug_tuple("Tree");
                        debug_trait_builder.finish()
                    }
                    (&Role::TreeTable,) => {
                        let mut debug_trait_builder = f.debug_tuple("TreeTable");
                        debug_trait_builder.finish()
                    }
                    (&Role::Unknown,) => {
                        let mut debug_trait_builder = f.debug_tuple("Unknown");
                        debug_trait_builder.finish()
                    }
                    (&Role::Viewport,) => {
                        let mut debug_trait_builder = f.debug_tuple("Viewport");
                        debug_trait_builder.finish()
                    }
                    (&Role::Window,) => {
                        let mut debug_trait_builder = f.debug_tuple("Window");
                        debug_trait_builder.finish()
                    }
                    (&Role::Extended,) => {
                        let mut debug_trait_builder = f.debug_tuple("Extended");
                        debug_trait_builder.finish()
                    }
                    (&Role::Header,) => {
                        let mut debug_trait_builder = f.debug_tuple("Header");
                        debug_trait_builder.finish()
                    }
                    (&Role::Footer,) => {
                        let mut debug_trait_builder = f.debug_tuple("Footer");
                        debug_trait_builder.finish()
                    }
                    (&Role::Paragraph,) => {
                        let mut debug_trait_builder = f.debug_tuple("Paragraph");
                        debug_trait_builder.finish()
                    }
                    (&Role::Ruler,) => {
                        let mut debug_trait_builder = f.debug_tuple("Ruler");
                        debug_trait_builder.finish()
                    }
                    (&Role::Application,) => {
                        let mut debug_trait_builder = f.debug_tuple("Application");
                        debug_trait_builder.finish()
                    }
                    (&Role::Autocomplete,) => {
                        let mut debug_trait_builder = f.debug_tuple("Autocomplete");
                        debug_trait_builder.finish()
                    }
                    (&Role::Editbar,) => {
                        let mut debug_trait_builder = f.debug_tuple("Editbar");
                        debug_trait_builder.finish()
                    }
                    (&Role::Embedded,) => {
                        let mut debug_trait_builder = f.debug_tuple("Embedded");
                        debug_trait_builder.finish()
                    }
                    (&Role::Entry,) => {
                        let mut debug_trait_builder = f.debug_tuple("Entry");
                        debug_trait_builder.finish()
                    }
                    (&Role::Chart,) => {
                        let mut debug_trait_builder = f.debug_tuple("Chart");
                        debug_trait_builder.finish()
                    }
                    (&Role::Caption,) => {
                        let mut debug_trait_builder = f.debug_tuple("Caption");
                        debug_trait_builder.finish()
                    }
                    (&Role::DocumentFrame,) => {
                        let mut debug_trait_builder = f.debug_tuple("DocumentFrame");
                        debug_trait_builder.finish()
                    }
                    (&Role::Heading,) => {
                        let mut debug_trait_builder = f.debug_tuple("Heading");
                        debug_trait_builder.finish()
                    }
                    (&Role::Page,) => {
                        let mut debug_trait_builder = f.debug_tuple("Page");
                        debug_trait_builder.finish()
                    }
                    (&Role::Section,) => {
                        let mut debug_trait_builder = f.debug_tuple("Section");
                        debug_trait_builder.finish()
                    }
                    (&Role::RedundantObject,) => {
                        let mut debug_trait_builder = f.debug_tuple("RedundantObject");
                        debug_trait_builder.finish()
                    }
                    (&Role::Form,) => {
                        let mut debug_trait_builder = f.debug_tuple("Form");
                        debug_trait_builder.finish()
                    }
                    (&Role::Link,) => {
                        let mut debug_trait_builder = f.debug_tuple("Link");
                        debug_trait_builder.finish()
                    }
                    (&Role::InputMethodWindow,) => {
                        let mut debug_trait_builder = f.debug_tuple("InputMethodWindow");
                        debug_trait_builder.finish()
                    }
                    (&Role::TableRow,) => {
                        let mut debug_trait_builder = f.debug_tuple("TableRow");
                        debug_trait_builder.finish()
                    }
                    (&Role::TreeItem,) => {
                        let mut debug_trait_builder = f.debug_tuple("TreeItem");
                        debug_trait_builder.finish()
                    }
                    (&Role::DocumentSpreadsheet,) => {
                        let mut debug_trait_builder = f.debug_tuple("DocumentSpreadsheet");
                        debug_trait_builder.finish()
                    }
                    (&Role::DocumentPresentation,) => {
                        let mut debug_trait_builder = f.debug_tuple("DocumentPresentation");
                        debug_trait_builder.finish()
                    }
                    (&Role::DocumentText,) => {
                        let mut debug_trait_builder = f.debug_tuple("DocumentText");
                        debug_trait_builder.finish()
                    }
                    (&Role::DocumentWeb,) => {
                        let mut debug_trait_builder = f.debug_tuple("DocumentWeb");
                        debug_trait_builder.finish()
                    }
                    (&Role::DocumentEmail,) => {
                        let mut debug_trait_builder = f.debug_tuple("DocumentEmail");
                        debug_trait_builder.finish()
                    }
                    (&Role::Comment,) => {
                        let mut debug_trait_builder = f.debug_tuple("Comment");
                        debug_trait_builder.finish()
                    }
                    (&Role::ListBox,) => {
                        let mut debug_trait_builder = f.debug_tuple("ListBox");
                        debug_trait_builder.finish()
                    }
                    (&Role::Grouping,) => {
                        let mut debug_trait_builder = f.debug_tuple("Grouping");
                        debug_trait_builder.finish()
                    }
                    (&Role::ImageMap,) => {
                        let mut debug_trait_builder = f.debug_tuple("ImageMap");
                        debug_trait_builder.finish()
                    }
                    (&Role::Notification,) => {
                        let mut debug_trait_builder = f.debug_tuple("Notification");
                        debug_trait_builder.finish()
                    }
                    (&Role::InfoBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("InfoBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::LevelBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("LevelBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::TitleBar,) => {
                        let mut debug_trait_builder = f.debug_tuple("TitleBar");
                        debug_trait_builder.finish()
                    }
                    (&Role::BlockQuote,) => {
                        let mut debug_trait_builder = f.debug_tuple("BlockQuote");
                        debug_trait_builder.finish()
                    }
                    (&Role::Audio,) => {
                        let mut debug_trait_builder = f.debug_tuple("Audio");
                        debug_trait_builder.finish()
                    }
                    (&Role::Video,) => {
                        let mut debug_trait_builder = f.debug_tuple("Video");
                        debug_trait_builder.finish()
                    }
                    (&Role::Definition,) => {
                        let mut debug_trait_builder = f.debug_tuple("Definition");
                        debug_trait_builder.finish()
                    }
                    (&Role::Article,) => {
                        let mut debug_trait_builder = f.debug_tuple("Article");
                        debug_trait_builder.finish()
                    }
                    (&Role::Landmark,) => {
                        let mut debug_trait_builder = f.debug_tuple("Landmark");
                        debug_trait_builder.finish()
                    }
                    (&Role::Log,) => {
                        let mut debug_trait_builder = f.debug_tuple("Log");
                        debug_trait_builder.finish()
                    }
                    (&Role::Marquee,) => {
                        let mut debug_trait_builder = f.debug_tuple("Marquee");
                        debug_trait_builder.finish()
                    }
                    (&Role::Math,) => {
                        let mut debug_trait_builder = f.debug_tuple("Math");
                        debug_trait_builder.finish()
                    }
                    (&Role::Rating,) => {
                        let mut debug_trait_builder = f.debug_tuple("Rating");
                        debug_trait_builder.finish()
                    }
                    (&Role::Timer,) => {
                        let mut debug_trait_builder = f.debug_tuple("Timer");
                        debug_trait_builder.finish()
                    }
                    (&Role::Static,) => {
                        let mut debug_trait_builder = f.debug_tuple("Static");
                        debug_trait_builder.finish()
                    }
                    (&Role::MathFraction,) => {
                        let mut debug_trait_builder = f.debug_tuple("MathFraction");
                        debug_trait_builder.finish()
                    }
                    (&Role::MathRoot,) => {
                        let mut debug_trait_builder = f.debug_tuple("MathRoot");
                        debug_trait_builder.finish()
                    }
                    (&Role::Subscript,) => {
                        let mut debug_trait_builder = f.debug_tuple("Subscript");
                        debug_trait_builder.finish()
                    }
                    (&Role::Superscript,) => {
                        let mut debug_trait_builder = f.debug_tuple("Superscript");
                        debug_trait_builder.finish()
                    }
                    (&Role::DescriptionList,) => {
                        let mut debug_trait_builder = f.debug_tuple("DescriptionList");
                        debug_trait_builder.finish()
                    }
                    (&Role::DescriptionTerm,) => {
                        let mut debug_trait_builder = f.debug_tuple("DescriptionTerm");
                        debug_trait_builder.finish()
                    }
                    (&Role::DescriptionValue,) => {
                        let mut debug_trait_builder = f.debug_tuple("DescriptionValue");
                        debug_trait_builder.finish()
                    }
                    (&Role::Footnote,) => {
                        let mut debug_trait_builder = f.debug_tuple("Footnote");
                        debug_trait_builder.finish()
                    }
                    (&Role::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&Role::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Role {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Role {
            #[inline]
            fn eq(&self, other: &Role) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Role) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Role {
            #[inline]
            fn cmp(&self, other: &Role) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                    ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                    cmp => cmp,
                                }
                            }
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Role {
            #[inline]
            fn partial_cmp(&self, other: &Role) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0),
                                    &(*__arg_1_0),
                                ) {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                    }
                                    cmp => cmp,
                                }
                            }
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &Role) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &Role) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &Role) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &Role) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Role::__Unknown(ref __self_0), &Role::__Unknown(ref __arg_1_0)) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Role {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&Role::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Role {
            #[inline]
            fn clone(&self) -> Role {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Role {}
        impl fmt::Display for Role {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["Role::"],
                    &match (&match *self {
                        Role::Invalid => "Invalid",
                        Role::AcceleratorLabel => "AcceleratorLabel",
                        Role::Alert => "Alert",
                        Role::Animation => "Animation",
                        Role::Arrow => "Arrow",
                        Role::Calendar => "Calendar",
                        Role::Canvas => "Canvas",
                        Role::CheckBox => "CheckBox",
                        Role::CheckMenuItem => "CheckMenuItem",
                        Role::ColorChooser => "ColorChooser",
                        Role::ColumnHeader => "ColumnHeader",
                        Role::ComboBox => "ComboBox",
                        Role::DateEditor => "DateEditor",
                        Role::DesktopIcon => "DesktopIcon",
                        Role::DesktopFrame => "DesktopFrame",
                        Role::Dial => "Dial",
                        Role::Dialog => "Dialog",
                        Role::DirectoryPane => "DirectoryPane",
                        Role::DrawingArea => "DrawingArea",
                        Role::FileChooser => "FileChooser",
                        Role::Filler => "Filler",
                        Role::FocusTraversable => "FocusTraversable",
                        Role::FontChooser => "FontChooser",
                        Role::Frame => "Frame",
                        Role::GlassPane => "GlassPane",
                        Role::HtmlContainer => "HtmlContainer",
                        Role::Icon => "Icon",
                        Role::Image => "Image",
                        Role::InternalFrame => "InternalFrame",
                        Role::Label => "Label",
                        Role::LayeredPane => "LayeredPane",
                        Role::List => "List",
                        Role::ListItem => "ListItem",
                        Role::Menu => "Menu",
                        Role::MenuBar => "MenuBar",
                        Role::MenuItem => "MenuItem",
                        Role::OptionPane => "OptionPane",
                        Role::PageTab => "PageTab",
                        Role::PageTabList => "PageTabList",
                        Role::Panel => "Panel",
                        Role::PasswordText => "PasswordText",
                        Role::PopupMenu => "PopupMenu",
                        Role::ProgressBar => "ProgressBar",
                        Role::PushButton => "PushButton",
                        Role::RadioButton => "RadioButton",
                        Role::RadioMenuItem => "RadioMenuItem",
                        Role::RootPane => "RootPane",
                        Role::RowHeader => "RowHeader",
                        Role::ScrollBar => "ScrollBar",
                        Role::ScrollPane => "ScrollPane",
                        Role::Separator => "Separator",
                        Role::Slider => "Slider",
                        Role::SpinButton => "SpinButton",
                        Role::SplitPane => "SplitPane",
                        Role::StatusBar => "StatusBar",
                        Role::Table => "Table",
                        Role::TableCell => "TableCell",
                        Role::TableColumnHeader => "TableColumnHeader",
                        Role::TableRowHeader => "TableRowHeader",
                        Role::TearoffMenuItem => "TearoffMenuItem",
                        Role::Terminal => "Terminal",
                        Role::Text => "Text",
                        Role::ToggleButton => "ToggleButton",
                        Role::ToolBar => "ToolBar",
                        Role::ToolTip => "ToolTip",
                        Role::Tree => "Tree",
                        Role::TreeTable => "TreeTable",
                        Role::Unknown => "Unknown",
                        Role::Viewport => "Viewport",
                        Role::Window => "Window",
                        Role::Extended => "Extended",
                        Role::Header => "Header",
                        Role::Footer => "Footer",
                        Role::Paragraph => "Paragraph",
                        Role::Ruler => "Ruler",
                        Role::Application => "Application",
                        Role::Autocomplete => "Autocomplete",
                        Role::Editbar => "Editbar",
                        Role::Embedded => "Embedded",
                        Role::Entry => "Entry",
                        Role::Chart => "Chart",
                        Role::Caption => "Caption",
                        Role::DocumentFrame => "DocumentFrame",
                        Role::Heading => "Heading",
                        Role::Page => "Page",
                        Role::Section => "Section",
                        Role::RedundantObject => "RedundantObject",
                        Role::Form => "Form",
                        Role::Link => "Link",
                        Role::InputMethodWindow => "InputMethodWindow",
                        Role::TableRow => "TableRow",
                        Role::TreeItem => "TreeItem",
                        Role::DocumentSpreadsheet => "DocumentSpreadsheet",
                        Role::DocumentPresentation => "DocumentPresentation",
                        Role::DocumentText => "DocumentText",
                        Role::DocumentWeb => "DocumentWeb",
                        Role::DocumentEmail => "DocumentEmail",
                        Role::Comment => "Comment",
                        Role::ListBox => "ListBox",
                        Role::Grouping => "Grouping",
                        Role::ImageMap => "ImageMap",
                        Role::Notification => "Notification",
                        Role::InfoBar => "InfoBar",
                        Role::LevelBar => "LevelBar",
                        Role::TitleBar => "TitleBar",
                        Role::BlockQuote => "BlockQuote",
                        Role::Audio => "Audio",
                        Role::Video => "Video",
                        Role::Definition => "Definition",
                        Role::Article => "Article",
                        Role::Landmark => "Landmark",
                        Role::Log => "Log",
                        Role::Marquee => "Marquee",
                        Role::Math => "Math",
                        Role::Rating => "Rating",
                        Role::Timer => "Timer",
                        Role::Static => "Static",
                        Role::MathFraction => "MathFraction",
                        Role::MathRoot => "MathRoot",
                        Role::Subscript => "Subscript",
                        Role::Superscript => "Superscript",
                        Role::DescriptionList => "DescriptionList",
                        Role::DescriptionTerm => "DescriptionTerm",
                        Role::DescriptionValue => "DescriptionValue",
                        Role::Footnote => "Footnote",
                        Role::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for Role {
            type GlibType = atspi_sys::AtspiRole;
            fn to_glib(&self) -> atspi_sys::AtspiRole {
                match *self {
                    Role::Invalid => atspi_sys::ATSPI_ROLE_INVALID,
                    Role::AcceleratorLabel => atspi_sys::ATSPI_ROLE_ACCELERATOR_LABEL,
                    Role::Alert => atspi_sys::ATSPI_ROLE_ALERT,
                    Role::Animation => atspi_sys::ATSPI_ROLE_ANIMATION,
                    Role::Arrow => atspi_sys::ATSPI_ROLE_ARROW,
                    Role::Calendar => atspi_sys::ATSPI_ROLE_CALENDAR,
                    Role::Canvas => atspi_sys::ATSPI_ROLE_CANVAS,
                    Role::CheckBox => atspi_sys::ATSPI_ROLE_CHECK_BOX,
                    Role::CheckMenuItem => atspi_sys::ATSPI_ROLE_CHECK_MENU_ITEM,
                    Role::ColorChooser => atspi_sys::ATSPI_ROLE_COLOR_CHOOSER,
                    Role::ColumnHeader => atspi_sys::ATSPI_ROLE_COLUMN_HEADER,
                    Role::ComboBox => atspi_sys::ATSPI_ROLE_COMBO_BOX,
                    Role::DateEditor => atspi_sys::ATSPI_ROLE_DATE_EDITOR,
                    Role::DesktopIcon => atspi_sys::ATSPI_ROLE_DESKTOP_ICON,
                    Role::DesktopFrame => atspi_sys::ATSPI_ROLE_DESKTOP_FRAME,
                    Role::Dial => atspi_sys::ATSPI_ROLE_DIAL,
                    Role::Dialog => atspi_sys::ATSPI_ROLE_DIALOG,
                    Role::DirectoryPane => atspi_sys::ATSPI_ROLE_DIRECTORY_PANE,
                    Role::DrawingArea => atspi_sys::ATSPI_ROLE_DRAWING_AREA,
                    Role::FileChooser => atspi_sys::ATSPI_ROLE_FILE_CHOOSER,
                    Role::Filler => atspi_sys::ATSPI_ROLE_FILLER,
                    Role::FocusTraversable => atspi_sys::ATSPI_ROLE_FOCUS_TRAVERSABLE,
                    Role::FontChooser => atspi_sys::ATSPI_ROLE_FONT_CHOOSER,
                    Role::Frame => atspi_sys::ATSPI_ROLE_FRAME,
                    Role::GlassPane => atspi_sys::ATSPI_ROLE_GLASS_PANE,
                    Role::HtmlContainer => atspi_sys::ATSPI_ROLE_HTML_CONTAINER,
                    Role::Icon => atspi_sys::ATSPI_ROLE_ICON,
                    Role::Image => atspi_sys::ATSPI_ROLE_IMAGE,
                    Role::InternalFrame => atspi_sys::ATSPI_ROLE_INTERNAL_FRAME,
                    Role::Label => atspi_sys::ATSPI_ROLE_LABEL,
                    Role::LayeredPane => atspi_sys::ATSPI_ROLE_LAYERED_PANE,
                    Role::List => atspi_sys::ATSPI_ROLE_LIST,
                    Role::ListItem => atspi_sys::ATSPI_ROLE_LIST_ITEM,
                    Role::Menu => atspi_sys::ATSPI_ROLE_MENU,
                    Role::MenuBar => atspi_sys::ATSPI_ROLE_MENU_BAR,
                    Role::MenuItem => atspi_sys::ATSPI_ROLE_MENU_ITEM,
                    Role::OptionPane => atspi_sys::ATSPI_ROLE_OPTION_PANE,
                    Role::PageTab => atspi_sys::ATSPI_ROLE_PAGE_TAB,
                    Role::PageTabList => atspi_sys::ATSPI_ROLE_PAGE_TAB_LIST,
                    Role::Panel => atspi_sys::ATSPI_ROLE_PANEL,
                    Role::PasswordText => atspi_sys::ATSPI_ROLE_PASSWORD_TEXT,
                    Role::PopupMenu => atspi_sys::ATSPI_ROLE_POPUP_MENU,
                    Role::ProgressBar => atspi_sys::ATSPI_ROLE_PROGRESS_BAR,
                    Role::PushButton => atspi_sys::ATSPI_ROLE_PUSH_BUTTON,
                    Role::RadioButton => atspi_sys::ATSPI_ROLE_RADIO_BUTTON,
                    Role::RadioMenuItem => atspi_sys::ATSPI_ROLE_RADIO_MENU_ITEM,
                    Role::RootPane => atspi_sys::ATSPI_ROLE_ROOT_PANE,
                    Role::RowHeader => atspi_sys::ATSPI_ROLE_ROW_HEADER,
                    Role::ScrollBar => atspi_sys::ATSPI_ROLE_SCROLL_BAR,
                    Role::ScrollPane => atspi_sys::ATSPI_ROLE_SCROLL_PANE,
                    Role::Separator => atspi_sys::ATSPI_ROLE_SEPARATOR,
                    Role::Slider => atspi_sys::ATSPI_ROLE_SLIDER,
                    Role::SpinButton => atspi_sys::ATSPI_ROLE_SPIN_BUTTON,
                    Role::SplitPane => atspi_sys::ATSPI_ROLE_SPLIT_PANE,
                    Role::StatusBar => atspi_sys::ATSPI_ROLE_STATUS_BAR,
                    Role::Table => atspi_sys::ATSPI_ROLE_TABLE,
                    Role::TableCell => atspi_sys::ATSPI_ROLE_TABLE_CELL,
                    Role::TableColumnHeader => atspi_sys::ATSPI_ROLE_TABLE_COLUMN_HEADER,
                    Role::TableRowHeader => atspi_sys::ATSPI_ROLE_TABLE_ROW_HEADER,
                    Role::TearoffMenuItem => atspi_sys::ATSPI_ROLE_TEAROFF_MENU_ITEM,
                    Role::Terminal => atspi_sys::ATSPI_ROLE_TERMINAL,
                    Role::Text => atspi_sys::ATSPI_ROLE_TEXT,
                    Role::ToggleButton => atspi_sys::ATSPI_ROLE_TOGGLE_BUTTON,
                    Role::ToolBar => atspi_sys::ATSPI_ROLE_TOOL_BAR,
                    Role::ToolTip => atspi_sys::ATSPI_ROLE_TOOL_TIP,
                    Role::Tree => atspi_sys::ATSPI_ROLE_TREE,
                    Role::TreeTable => atspi_sys::ATSPI_ROLE_TREE_TABLE,
                    Role::Unknown => atspi_sys::ATSPI_ROLE_UNKNOWN,
                    Role::Viewport => atspi_sys::ATSPI_ROLE_VIEWPORT,
                    Role::Window => atspi_sys::ATSPI_ROLE_WINDOW,
                    Role::Extended => atspi_sys::ATSPI_ROLE_EXTENDED,
                    Role::Header => atspi_sys::ATSPI_ROLE_HEADER,
                    Role::Footer => atspi_sys::ATSPI_ROLE_FOOTER,
                    Role::Paragraph => atspi_sys::ATSPI_ROLE_PARAGRAPH,
                    Role::Ruler => atspi_sys::ATSPI_ROLE_RULER,
                    Role::Application => atspi_sys::ATSPI_ROLE_APPLICATION,
                    Role::Autocomplete => atspi_sys::ATSPI_ROLE_AUTOCOMPLETE,
                    Role::Editbar => atspi_sys::ATSPI_ROLE_EDITBAR,
                    Role::Embedded => atspi_sys::ATSPI_ROLE_EMBEDDED,
                    Role::Entry => atspi_sys::ATSPI_ROLE_ENTRY,
                    Role::Chart => atspi_sys::ATSPI_ROLE_CHART,
                    Role::Caption => atspi_sys::ATSPI_ROLE_CAPTION,
                    Role::DocumentFrame => atspi_sys::ATSPI_ROLE_DOCUMENT_FRAME,
                    Role::Heading => atspi_sys::ATSPI_ROLE_HEADING,
                    Role::Page => atspi_sys::ATSPI_ROLE_PAGE,
                    Role::Section => atspi_sys::ATSPI_ROLE_SECTION,
                    Role::RedundantObject => atspi_sys::ATSPI_ROLE_REDUNDANT_OBJECT,
                    Role::Form => atspi_sys::ATSPI_ROLE_FORM,
                    Role::Link => atspi_sys::ATSPI_ROLE_LINK,
                    Role::InputMethodWindow => atspi_sys::ATSPI_ROLE_INPUT_METHOD_WINDOW,
                    Role::TableRow => atspi_sys::ATSPI_ROLE_TABLE_ROW,
                    Role::TreeItem => atspi_sys::ATSPI_ROLE_TREE_ITEM,
                    Role::DocumentSpreadsheet => atspi_sys::ATSPI_ROLE_DOCUMENT_SPREADSHEET,
                    Role::DocumentPresentation => atspi_sys::ATSPI_ROLE_DOCUMENT_PRESENTATION,
                    Role::DocumentText => atspi_sys::ATSPI_ROLE_DOCUMENT_TEXT,
                    Role::DocumentWeb => atspi_sys::ATSPI_ROLE_DOCUMENT_WEB,
                    Role::DocumentEmail => atspi_sys::ATSPI_ROLE_DOCUMENT_EMAIL,
                    Role::Comment => atspi_sys::ATSPI_ROLE_COMMENT,
                    Role::ListBox => atspi_sys::ATSPI_ROLE_LIST_BOX,
                    Role::Grouping => atspi_sys::ATSPI_ROLE_GROUPING,
                    Role::ImageMap => atspi_sys::ATSPI_ROLE_IMAGE_MAP,
                    Role::Notification => atspi_sys::ATSPI_ROLE_NOTIFICATION,
                    Role::InfoBar => atspi_sys::ATSPI_ROLE_INFO_BAR,
                    Role::LevelBar => atspi_sys::ATSPI_ROLE_LEVEL_BAR,
                    Role::TitleBar => atspi_sys::ATSPI_ROLE_TITLE_BAR,
                    Role::BlockQuote => atspi_sys::ATSPI_ROLE_BLOCK_QUOTE,
                    Role::Audio => atspi_sys::ATSPI_ROLE_AUDIO,
                    Role::Video => atspi_sys::ATSPI_ROLE_VIDEO,
                    Role::Definition => atspi_sys::ATSPI_ROLE_DEFINITION,
                    Role::Article => atspi_sys::ATSPI_ROLE_ARTICLE,
                    Role::Landmark => atspi_sys::ATSPI_ROLE_LANDMARK,
                    Role::Log => atspi_sys::ATSPI_ROLE_LOG,
                    Role::Marquee => atspi_sys::ATSPI_ROLE_MARQUEE,
                    Role::Math => atspi_sys::ATSPI_ROLE_MATH,
                    Role::Rating => atspi_sys::ATSPI_ROLE_RATING,
                    Role::Timer => atspi_sys::ATSPI_ROLE_TIMER,
                    Role::Static => atspi_sys::ATSPI_ROLE_STATIC,
                    Role::MathFraction => atspi_sys::ATSPI_ROLE_MATH_FRACTION,
                    Role::MathRoot => atspi_sys::ATSPI_ROLE_MATH_ROOT,
                    Role::Subscript => atspi_sys::ATSPI_ROLE_SUBSCRIPT,
                    Role::Superscript => atspi_sys::ATSPI_ROLE_SUPERSCRIPT,
                    Role::DescriptionList => atspi_sys::ATSPI_ROLE_DESCRIPTION_LIST,
                    Role::DescriptionTerm => atspi_sys::ATSPI_ROLE_DESCRIPTION_TERM,
                    Role::DescriptionValue => atspi_sys::ATSPI_ROLE_DESCRIPTION_VALUE,
                    Role::Footnote => atspi_sys::ATSPI_ROLE_FOOTNOTE,
                    Role::LastDefined => atspi_sys::ATSPI_ROLE_LAST_DEFINED,
                    Role::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiRole> for Role {
            fn from_glib(value: atspi_sys::AtspiRole) -> Self {
                match value {
                    0 => Role::Invalid,
                    1 => Role::AcceleratorLabel,
                    2 => Role::Alert,
                    3 => Role::Animation,
                    4 => Role::Arrow,
                    5 => Role::Calendar,
                    6 => Role::Canvas,
                    7 => Role::CheckBox,
                    8 => Role::CheckMenuItem,
                    9 => Role::ColorChooser,
                    10 => Role::ColumnHeader,
                    11 => Role::ComboBox,
                    12 => Role::DateEditor,
                    13 => Role::DesktopIcon,
                    14 => Role::DesktopFrame,
                    15 => Role::Dial,
                    16 => Role::Dialog,
                    17 => Role::DirectoryPane,
                    18 => Role::DrawingArea,
                    19 => Role::FileChooser,
                    20 => Role::Filler,
                    21 => Role::FocusTraversable,
                    22 => Role::FontChooser,
                    23 => Role::Frame,
                    24 => Role::GlassPane,
                    25 => Role::HtmlContainer,
                    26 => Role::Icon,
                    27 => Role::Image,
                    28 => Role::InternalFrame,
                    29 => Role::Label,
                    30 => Role::LayeredPane,
                    31 => Role::List,
                    32 => Role::ListItem,
                    33 => Role::Menu,
                    34 => Role::MenuBar,
                    35 => Role::MenuItem,
                    36 => Role::OptionPane,
                    37 => Role::PageTab,
                    38 => Role::PageTabList,
                    39 => Role::Panel,
                    40 => Role::PasswordText,
                    41 => Role::PopupMenu,
                    42 => Role::ProgressBar,
                    43 => Role::PushButton,
                    44 => Role::RadioButton,
                    45 => Role::RadioMenuItem,
                    46 => Role::RootPane,
                    47 => Role::RowHeader,
                    48 => Role::ScrollBar,
                    49 => Role::ScrollPane,
                    50 => Role::Separator,
                    51 => Role::Slider,
                    52 => Role::SpinButton,
                    53 => Role::SplitPane,
                    54 => Role::StatusBar,
                    55 => Role::Table,
                    56 => Role::TableCell,
                    57 => Role::TableColumnHeader,
                    58 => Role::TableRowHeader,
                    59 => Role::TearoffMenuItem,
                    60 => Role::Terminal,
                    61 => Role::Text,
                    62 => Role::ToggleButton,
                    63 => Role::ToolBar,
                    64 => Role::ToolTip,
                    65 => Role::Tree,
                    66 => Role::TreeTable,
                    67 => Role::Unknown,
                    68 => Role::Viewport,
                    69 => Role::Window,
                    70 => Role::Extended,
                    71 => Role::Header,
                    72 => Role::Footer,
                    73 => Role::Paragraph,
                    74 => Role::Ruler,
                    75 => Role::Application,
                    76 => Role::Autocomplete,
                    77 => Role::Editbar,
                    78 => Role::Embedded,
                    79 => Role::Entry,
                    80 => Role::Chart,
                    81 => Role::Caption,
                    82 => Role::DocumentFrame,
                    83 => Role::Heading,
                    84 => Role::Page,
                    85 => Role::Section,
                    86 => Role::RedundantObject,
                    87 => Role::Form,
                    88 => Role::Link,
                    89 => Role::InputMethodWindow,
                    90 => Role::TableRow,
                    91 => Role::TreeItem,
                    92 => Role::DocumentSpreadsheet,
                    93 => Role::DocumentPresentation,
                    94 => Role::DocumentText,
                    95 => Role::DocumentWeb,
                    96 => Role::DocumentEmail,
                    97 => Role::Comment,
                    98 => Role::ListBox,
                    99 => Role::Grouping,
                    100 => Role::ImageMap,
                    101 => Role::Notification,
                    102 => Role::InfoBar,
                    103 => Role::LevelBar,
                    104 => Role::TitleBar,
                    105 => Role::BlockQuote,
                    106 => Role::Audio,
                    107 => Role::Video,
                    108 => Role::Definition,
                    109 => Role::Article,
                    110 => Role::Landmark,
                    111 => Role::Log,
                    112 => Role::Marquee,
                    113 => Role::Math,
                    114 => Role::Rating,
                    115 => Role::Timer,
                    116 => Role::Static,
                    117 => Role::MathFraction,
                    118 => Role::MathRoot,
                    119 => Role::Subscript,
                    120 => Role::Superscript,
                    121 => Role::DescriptionList,
                    122 => Role::DescriptionTerm,
                    123 => Role::DescriptionValue,
                    124 => Role::Footnote,
                    125 => Role::LastDefined,
                    value => Role::__Unknown(value),
                }
            }
        }
        impl StaticType for Role {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_role_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for Role {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for Role {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for Role {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum StateType {
            Invalid,
            Active,
            Armed,
            Busy,
            Checked,
            Collapsed,
            Defunct,
            Editable,
            Enabled,
            Expandable,
            Expanded,
            Focusable,
            Focused,
            HasTooltip,
            Horizontal,
            Iconified,
            Modal,
            MultiLine,
            Multiselectable,
            Opaque,
            Pressed,
            Resizable,
            Selectable,
            Selected,
            Sensitive,
            Showing,
            SingleLine,
            Stale,
            Transient,
            Vertical,
            Visible,
            ManagesDescendants,
            Indeterminate,
            Required,
            Truncated,
            Animated,
            InvalidEntry,
            SupportsAutocompletion,
            SelectableText,
            IsDefault,
            Visited,
            Checkable,
            HasPopup,
            ReadOnly,
            LastDefined,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for StateType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&StateType::Invalid,) => {
                        let mut debug_trait_builder = f.debug_tuple("Invalid");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Active,) => {
                        let mut debug_trait_builder = f.debug_tuple("Active");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Armed,) => {
                        let mut debug_trait_builder = f.debug_tuple("Armed");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Busy,) => {
                        let mut debug_trait_builder = f.debug_tuple("Busy");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Checked,) => {
                        let mut debug_trait_builder = f.debug_tuple("Checked");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Collapsed,) => {
                        let mut debug_trait_builder = f.debug_tuple("Collapsed");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Defunct,) => {
                        let mut debug_trait_builder = f.debug_tuple("Defunct");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Editable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Editable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Enabled,) => {
                        let mut debug_trait_builder = f.debug_tuple("Enabled");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Expandable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Expandable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Expanded,) => {
                        let mut debug_trait_builder = f.debug_tuple("Expanded");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Focusable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Focusable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Focused,) => {
                        let mut debug_trait_builder = f.debug_tuple("Focused");
                        debug_trait_builder.finish()
                    }
                    (&StateType::HasTooltip,) => {
                        let mut debug_trait_builder = f.debug_tuple("HasTooltip");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Horizontal,) => {
                        let mut debug_trait_builder = f.debug_tuple("Horizontal");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Iconified,) => {
                        let mut debug_trait_builder = f.debug_tuple("Iconified");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Modal,) => {
                        let mut debug_trait_builder = f.debug_tuple("Modal");
                        debug_trait_builder.finish()
                    }
                    (&StateType::MultiLine,) => {
                        let mut debug_trait_builder = f.debug_tuple("MultiLine");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Multiselectable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Multiselectable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Opaque,) => {
                        let mut debug_trait_builder = f.debug_tuple("Opaque");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Pressed,) => {
                        let mut debug_trait_builder = f.debug_tuple("Pressed");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Resizable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Resizable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Selectable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Selectable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Selected,) => {
                        let mut debug_trait_builder = f.debug_tuple("Selected");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Sensitive,) => {
                        let mut debug_trait_builder = f.debug_tuple("Sensitive");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Showing,) => {
                        let mut debug_trait_builder = f.debug_tuple("Showing");
                        debug_trait_builder.finish()
                    }
                    (&StateType::SingleLine,) => {
                        let mut debug_trait_builder = f.debug_tuple("SingleLine");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Stale,) => {
                        let mut debug_trait_builder = f.debug_tuple("Stale");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Transient,) => {
                        let mut debug_trait_builder = f.debug_tuple("Transient");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Vertical,) => {
                        let mut debug_trait_builder = f.debug_tuple("Vertical");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Visible,) => {
                        let mut debug_trait_builder = f.debug_tuple("Visible");
                        debug_trait_builder.finish()
                    }
                    (&StateType::ManagesDescendants,) => {
                        let mut debug_trait_builder = f.debug_tuple("ManagesDescendants");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Indeterminate,) => {
                        let mut debug_trait_builder = f.debug_tuple("Indeterminate");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Required,) => {
                        let mut debug_trait_builder = f.debug_tuple("Required");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Truncated,) => {
                        let mut debug_trait_builder = f.debug_tuple("Truncated");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Animated,) => {
                        let mut debug_trait_builder = f.debug_tuple("Animated");
                        debug_trait_builder.finish()
                    }
                    (&StateType::InvalidEntry,) => {
                        let mut debug_trait_builder = f.debug_tuple("InvalidEntry");
                        debug_trait_builder.finish()
                    }
                    (&StateType::SupportsAutocompletion,) => {
                        let mut debug_trait_builder = f.debug_tuple("SupportsAutocompletion");
                        debug_trait_builder.finish()
                    }
                    (&StateType::SelectableText,) => {
                        let mut debug_trait_builder = f.debug_tuple("SelectableText");
                        debug_trait_builder.finish()
                    }
                    (&StateType::IsDefault,) => {
                        let mut debug_trait_builder = f.debug_tuple("IsDefault");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Visited,) => {
                        let mut debug_trait_builder = f.debug_tuple("Visited");
                        debug_trait_builder.finish()
                    }
                    (&StateType::Checkable,) => {
                        let mut debug_trait_builder = f.debug_tuple("Checkable");
                        debug_trait_builder.finish()
                    }
                    (&StateType::HasPopup,) => {
                        let mut debug_trait_builder = f.debug_tuple("HasPopup");
                        debug_trait_builder.finish()
                    }
                    (&StateType::ReadOnly,) => {
                        let mut debug_trait_builder = f.debug_tuple("ReadOnly");
                        debug_trait_builder.finish()
                    }
                    (&StateType::LastDefined,) => {
                        let mut debug_trait_builder = f.debug_tuple("LastDefined");
                        debug_trait_builder.finish()
                    }
                    (&StateType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for StateType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for StateType {
            #[inline]
            fn eq(&self, other: &StateType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &StateType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for StateType {
            #[inline]
            fn cmp(&self, other: &StateType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for StateType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &StateType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &StateType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &StateType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &StateType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &StateType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &StateType::__Unknown(ref __self_0),
                                &StateType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for StateType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&StateType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for StateType {
            #[inline]
            fn clone(&self) -> StateType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for StateType {}
        impl fmt::Display for StateType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["StateType::"],
                    &match (&match *self {
                        StateType::Invalid => "Invalid",
                        StateType::Active => "Active",
                        StateType::Armed => "Armed",
                        StateType::Busy => "Busy",
                        StateType::Checked => "Checked",
                        StateType::Collapsed => "Collapsed",
                        StateType::Defunct => "Defunct",
                        StateType::Editable => "Editable",
                        StateType::Enabled => "Enabled",
                        StateType::Expandable => "Expandable",
                        StateType::Expanded => "Expanded",
                        StateType::Focusable => "Focusable",
                        StateType::Focused => "Focused",
                        StateType::HasTooltip => "HasTooltip",
                        StateType::Horizontal => "Horizontal",
                        StateType::Iconified => "Iconified",
                        StateType::Modal => "Modal",
                        StateType::MultiLine => "MultiLine",
                        StateType::Multiselectable => "Multiselectable",
                        StateType::Opaque => "Opaque",
                        StateType::Pressed => "Pressed",
                        StateType::Resizable => "Resizable",
                        StateType::Selectable => "Selectable",
                        StateType::Selected => "Selected",
                        StateType::Sensitive => "Sensitive",
                        StateType::Showing => "Showing",
                        StateType::SingleLine => "SingleLine",
                        StateType::Stale => "Stale",
                        StateType::Transient => "Transient",
                        StateType::Vertical => "Vertical",
                        StateType::Visible => "Visible",
                        StateType::ManagesDescendants => "ManagesDescendants",
                        StateType::Indeterminate => "Indeterminate",
                        StateType::Required => "Required",
                        StateType::Truncated => "Truncated",
                        StateType::Animated => "Animated",
                        StateType::InvalidEntry => "InvalidEntry",
                        StateType::SupportsAutocompletion => "SupportsAutocompletion",
                        StateType::SelectableText => "SelectableText",
                        StateType::IsDefault => "IsDefault",
                        StateType::Visited => "Visited",
                        StateType::Checkable => "Checkable",
                        StateType::HasPopup => "HasPopup",
                        StateType::ReadOnly => "ReadOnly",
                        StateType::LastDefined => "LastDefined",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for StateType {
            type GlibType = atspi_sys::AtspiStateType;
            fn to_glib(&self) -> atspi_sys::AtspiStateType {
                match *self {
                    StateType::Invalid => atspi_sys::ATSPI_STATE_INVALID,
                    StateType::Active => atspi_sys::ATSPI_STATE_ACTIVE,
                    StateType::Armed => atspi_sys::ATSPI_STATE_ARMED,
                    StateType::Busy => atspi_sys::ATSPI_STATE_BUSY,
                    StateType::Checked => atspi_sys::ATSPI_STATE_CHECKED,
                    StateType::Collapsed => atspi_sys::ATSPI_STATE_COLLAPSED,
                    StateType::Defunct => atspi_sys::ATSPI_STATE_DEFUNCT,
                    StateType::Editable => atspi_sys::ATSPI_STATE_EDITABLE,
                    StateType::Enabled => atspi_sys::ATSPI_STATE_ENABLED,
                    StateType::Expandable => atspi_sys::ATSPI_STATE_EXPANDABLE,
                    StateType::Expanded => atspi_sys::ATSPI_STATE_EXPANDED,
                    StateType::Focusable => atspi_sys::ATSPI_STATE_FOCUSABLE,
                    StateType::Focused => atspi_sys::ATSPI_STATE_FOCUSED,
                    StateType::HasTooltip => atspi_sys::ATSPI_STATE_HAS_TOOLTIP,
                    StateType::Horizontal => atspi_sys::ATSPI_STATE_HORIZONTAL,
                    StateType::Iconified => atspi_sys::ATSPI_STATE_ICONIFIED,
                    StateType::Modal => atspi_sys::ATSPI_STATE_MODAL,
                    StateType::MultiLine => atspi_sys::ATSPI_STATE_MULTI_LINE,
                    StateType::Multiselectable => atspi_sys::ATSPI_STATE_MULTISELECTABLE,
                    StateType::Opaque => atspi_sys::ATSPI_STATE_OPAQUE,
                    StateType::Pressed => atspi_sys::ATSPI_STATE_PRESSED,
                    StateType::Resizable => atspi_sys::ATSPI_STATE_RESIZABLE,
                    StateType::Selectable => atspi_sys::ATSPI_STATE_SELECTABLE,
                    StateType::Selected => atspi_sys::ATSPI_STATE_SELECTED,
                    StateType::Sensitive => atspi_sys::ATSPI_STATE_SENSITIVE,
                    StateType::Showing => atspi_sys::ATSPI_STATE_SHOWING,
                    StateType::SingleLine => atspi_sys::ATSPI_STATE_SINGLE_LINE,
                    StateType::Stale => atspi_sys::ATSPI_STATE_STALE,
                    StateType::Transient => atspi_sys::ATSPI_STATE_TRANSIENT,
                    StateType::Vertical => atspi_sys::ATSPI_STATE_VERTICAL,
                    StateType::Visible => atspi_sys::ATSPI_STATE_VISIBLE,
                    StateType::ManagesDescendants => atspi_sys::ATSPI_STATE_MANAGES_DESCENDANTS,
                    StateType::Indeterminate => atspi_sys::ATSPI_STATE_INDETERMINATE,
                    StateType::Required => atspi_sys::ATSPI_STATE_REQUIRED,
                    StateType::Truncated => atspi_sys::ATSPI_STATE_TRUNCATED,
                    StateType::Animated => atspi_sys::ATSPI_STATE_ANIMATED,
                    StateType::InvalidEntry => atspi_sys::ATSPI_STATE_INVALID_ENTRY,
                    StateType::SupportsAutocompletion => {
                        atspi_sys::ATSPI_STATE_SUPPORTS_AUTOCOMPLETION
                    }
                    StateType::SelectableText => atspi_sys::ATSPI_STATE_SELECTABLE_TEXT,
                    StateType::IsDefault => atspi_sys::ATSPI_STATE_IS_DEFAULT,
                    StateType::Visited => atspi_sys::ATSPI_STATE_VISITED,
                    StateType::Checkable => atspi_sys::ATSPI_STATE_CHECKABLE,
                    StateType::HasPopup => atspi_sys::ATSPI_STATE_HAS_POPUP,
                    StateType::ReadOnly => atspi_sys::ATSPI_STATE_READ_ONLY,
                    StateType::LastDefined => atspi_sys::ATSPI_STATE_LAST_DEFINED,
                    StateType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiStateType> for StateType {
            fn from_glib(value: atspi_sys::AtspiStateType) -> Self {
                match value {
                    0 => StateType::Invalid,
                    1 => StateType::Active,
                    2 => StateType::Armed,
                    3 => StateType::Busy,
                    4 => StateType::Checked,
                    5 => StateType::Collapsed,
                    6 => StateType::Defunct,
                    7 => StateType::Editable,
                    8 => StateType::Enabled,
                    9 => StateType::Expandable,
                    10 => StateType::Expanded,
                    11 => StateType::Focusable,
                    12 => StateType::Focused,
                    13 => StateType::HasTooltip,
                    14 => StateType::Horizontal,
                    15 => StateType::Iconified,
                    16 => StateType::Modal,
                    17 => StateType::MultiLine,
                    18 => StateType::Multiselectable,
                    19 => StateType::Opaque,
                    20 => StateType::Pressed,
                    21 => StateType::Resizable,
                    22 => StateType::Selectable,
                    23 => StateType::Selected,
                    24 => StateType::Sensitive,
                    25 => StateType::Showing,
                    26 => StateType::SingleLine,
                    27 => StateType::Stale,
                    28 => StateType::Transient,
                    29 => StateType::Vertical,
                    30 => StateType::Visible,
                    31 => StateType::ManagesDescendants,
                    32 => StateType::Indeterminate,
                    33 => StateType::Required,
                    34 => StateType::Truncated,
                    35 => StateType::Animated,
                    36 => StateType::InvalidEntry,
                    37 => StateType::SupportsAutocompletion,
                    38 => StateType::SelectableText,
                    39 => StateType::IsDefault,
                    40 => StateType::Visited,
                    41 => StateType::Checkable,
                    42 => StateType::HasPopup,
                    43 => StateType::ReadOnly,
                    44 => StateType::LastDefined,
                    value => StateType::__Unknown(value),
                }
            }
        }
        impl StaticType for StateType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_state_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for StateType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for StateType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for StateType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum TextBoundaryType {
            Char,
            WordStart,
            WordEnd,
            SentenceStart,
            SentenceEnd,
            LineStart,
            LineEnd,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TextBoundaryType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TextBoundaryType::Char,) => {
                        let mut debug_trait_builder = f.debug_tuple("Char");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::WordStart,) => {
                        let mut debug_trait_builder = f.debug_tuple("WordStart");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::WordEnd,) => {
                        let mut debug_trait_builder = f.debug_tuple("WordEnd");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::SentenceStart,) => {
                        let mut debug_trait_builder = f.debug_tuple("SentenceStart");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::SentenceEnd,) => {
                        let mut debug_trait_builder = f.debug_tuple("SentenceEnd");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::LineStart,) => {
                        let mut debug_trait_builder = f.debug_tuple("LineStart");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::LineEnd,) => {
                        let mut debug_trait_builder = f.debug_tuple("LineEnd");
                        debug_trait_builder.finish()
                    }
                    (&TextBoundaryType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for TextBoundaryType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TextBoundaryType {
            #[inline]
            fn eq(&self, other: &TextBoundaryType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &TextBoundaryType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for TextBoundaryType {
            #[inline]
            fn cmp(&self, other: &TextBoundaryType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for TextBoundaryType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TextBoundaryType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &TextBoundaryType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &TextBoundaryType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &TextBoundaryType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &TextBoundaryType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextBoundaryType::__Unknown(ref __self_0),
                                &TextBoundaryType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for TextBoundaryType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&TextBoundaryType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TextBoundaryType {
            #[inline]
            fn clone(&self) -> TextBoundaryType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TextBoundaryType {}
        impl fmt::Display for TextBoundaryType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["TextBoundaryType::"],
                    &match (&match *self {
                        TextBoundaryType::Char => "Char",
                        TextBoundaryType::WordStart => "WordStart",
                        TextBoundaryType::WordEnd => "WordEnd",
                        TextBoundaryType::SentenceStart => "SentenceStart",
                        TextBoundaryType::SentenceEnd => "SentenceEnd",
                        TextBoundaryType::LineStart => "LineStart",
                        TextBoundaryType::LineEnd => "LineEnd",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for TextBoundaryType {
            type GlibType = atspi_sys::AtspiTextBoundaryType;
            fn to_glib(&self) -> atspi_sys::AtspiTextBoundaryType {
                match *self {
                    TextBoundaryType::Char => atspi_sys::ATSPI_TEXT_BOUNDARY_CHAR,
                    TextBoundaryType::WordStart => atspi_sys::ATSPI_TEXT_BOUNDARY_WORD_START,
                    TextBoundaryType::WordEnd => atspi_sys::ATSPI_TEXT_BOUNDARY_WORD_END,
                    TextBoundaryType::SentenceStart => {
                        atspi_sys::ATSPI_TEXT_BOUNDARY_SENTENCE_START
                    }
                    TextBoundaryType::SentenceEnd => atspi_sys::ATSPI_TEXT_BOUNDARY_SENTENCE_END,
                    TextBoundaryType::LineStart => atspi_sys::ATSPI_TEXT_BOUNDARY_LINE_START,
                    TextBoundaryType::LineEnd => atspi_sys::ATSPI_TEXT_BOUNDARY_LINE_END,
                    TextBoundaryType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiTextBoundaryType> for TextBoundaryType {
            fn from_glib(value: atspi_sys::AtspiTextBoundaryType) -> Self {
                match value {
                    0 => TextBoundaryType::Char,
                    1 => TextBoundaryType::WordStart,
                    2 => TextBoundaryType::WordEnd,
                    3 => TextBoundaryType::SentenceStart,
                    4 => TextBoundaryType::SentenceEnd,
                    5 => TextBoundaryType::LineStart,
                    6 => TextBoundaryType::LineEnd,
                    value => TextBoundaryType::__Unknown(value),
                }
            }
        }
        impl StaticType for TextBoundaryType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_text_boundary_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for TextBoundaryType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for TextBoundaryType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for TextBoundaryType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum TextClipType {
            None,
            Min,
            Max,
            Both,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TextClipType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TextClipType::None,) => {
                        let mut debug_trait_builder = f.debug_tuple("None");
                        debug_trait_builder.finish()
                    }
                    (&TextClipType::Min,) => {
                        let mut debug_trait_builder = f.debug_tuple("Min");
                        debug_trait_builder.finish()
                    }
                    (&TextClipType::Max,) => {
                        let mut debug_trait_builder = f.debug_tuple("Max");
                        debug_trait_builder.finish()
                    }
                    (&TextClipType::Both,) => {
                        let mut debug_trait_builder = f.debug_tuple("Both");
                        debug_trait_builder.finish()
                    }
                    (&TextClipType::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for TextClipType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TextClipType {
            #[inline]
            fn eq(&self, other: &TextClipType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &TextClipType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for TextClipType {
            #[inline]
            fn cmp(&self, other: &TextClipType) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for TextClipType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TextClipType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &TextClipType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &TextClipType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &TextClipType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &TextClipType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextClipType::__Unknown(ref __self_0),
                                &TextClipType::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for TextClipType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&TextClipType::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TextClipType {
            #[inline]
            fn clone(&self) -> TextClipType {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TextClipType {}
        impl fmt::Display for TextClipType {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["TextClipType::"],
                    &match (&match *self {
                        TextClipType::None => "None",
                        TextClipType::Min => "Min",
                        TextClipType::Max => "Max",
                        TextClipType::Both => "Both",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for TextClipType {
            type GlibType = atspi_sys::AtspiTextClipType;
            fn to_glib(&self) -> atspi_sys::AtspiTextClipType {
                match *self {
                    TextClipType::None => atspi_sys::ATSPI_TEXT_CLIP_NONE,
                    TextClipType::Min => atspi_sys::ATSPI_TEXT_CLIP_MIN,
                    TextClipType::Max => atspi_sys::ATSPI_TEXT_CLIP_MAX,
                    TextClipType::Both => atspi_sys::ATSPI_TEXT_CLIP_BOTH,
                    TextClipType::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiTextClipType> for TextClipType {
            fn from_glib(value: atspi_sys::AtspiTextClipType) -> Self {
                match value {
                    0 => TextClipType::None,
                    1 => TextClipType::Min,
                    2 => TextClipType::Max,
                    3 => TextClipType::Both,
                    value => TextClipType::__Unknown(value),
                }
            }
        }
        impl StaticType for TextClipType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_text_clip_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for TextClipType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for TextClipType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for TextClipType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub enum TextGranularity {
            Char,
            Word,
            Sentence,
            Line,
            Paragraph,
            #[doc(hidden)]
            __Unknown(i32),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TextGranularity {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TextGranularity::Char,) => {
                        let mut debug_trait_builder = f.debug_tuple("Char");
                        debug_trait_builder.finish()
                    }
                    (&TextGranularity::Word,) => {
                        let mut debug_trait_builder = f.debug_tuple("Word");
                        debug_trait_builder.finish()
                    }
                    (&TextGranularity::Sentence,) => {
                        let mut debug_trait_builder = f.debug_tuple("Sentence");
                        debug_trait_builder.finish()
                    }
                    (&TextGranularity::Line,) => {
                        let mut debug_trait_builder = f.debug_tuple("Line");
                        debug_trait_builder.finish()
                    }
                    (&TextGranularity::Paragraph,) => {
                        let mut debug_trait_builder = f.debug_tuple("Paragraph");
                        debug_trait_builder.finish()
                    }
                    (&TextGranularity::__Unknown(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("__Unknown");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for TextGranularity {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TextGranularity {
            #[inline]
            fn eq(&self, other: &TextGranularity) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &TextGranularity) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for TextGranularity {
            #[inline]
            fn cmp(&self, other: &TextGranularity) -> ::core::cmp::Ordering {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            },
                            _ => ::core::cmp::Ordering::Equal,
                        }
                    } else {
                        __self_vi.cmp(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for TextGranularity {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TextGranularity,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0),
                                &(*__arg_1_0),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            },
                            _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        }
                    } else {
                        __self_vi.partial_cmp(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn lt(&self, other: &TextGranularity) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) == ::core::cmp::Ordering::Less
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.lt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn le(&self, other: &TextGranularity) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                ) != ::core::cmp::Ordering::Greater
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.le(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn gt(&self, other: &TextGranularity) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) == ::core::cmp::Ordering::Greater
                            }
                            _ => false,
                        }
                    } else {
                        __self_vi.gt(&__arg_1_vi)
                    }
                }
            }
            #[inline]
            fn ge(&self, other: &TextGranularity) -> bool {
                {
                    let __self_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::core::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &TextGranularity::__Unknown(ref __self_0),
                                &TextGranularity::__Unknown(ref __arg_1_0),
                            ) => {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0),
                                        &(*__arg_1_0),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                ) != ::core::cmp::Ordering::Less
                            }
                            _ => true,
                        }
                    } else {
                        __self_vi.ge(&__arg_1_vi)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for TextGranularity {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&TextGranularity::__Unknown(ref __self_0),) => {
                        ::core::hash::Hash::hash(
                            &unsafe { ::core::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::core::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TextGranularity {
            #[inline]
            fn clone(&self) -> TextGranularity {
                {
                    let _: ::core::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TextGranularity {}
        impl fmt::Display for TextGranularity {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["TextGranularity::"],
                    &match (&match *self {
                        TextGranularity::Char => "Char",
                        TextGranularity::Word => "Word",
                        TextGranularity::Sentence => "Sentence",
                        TextGranularity::Line => "Line",
                        TextGranularity::Paragraph => "Paragraph",
                        _ => "Unknown",
                    },)
                    {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[doc(hidden)]
        impl ToGlib for TextGranularity {
            type GlibType = atspi_sys::AtspiTextGranularity;
            fn to_glib(&self) -> atspi_sys::AtspiTextGranularity {
                match *self {
                    TextGranularity::Char => atspi_sys::ATSPI_TEXT_GRANULARITY_CHAR,
                    TextGranularity::Word => atspi_sys::ATSPI_TEXT_GRANULARITY_WORD,
                    TextGranularity::Sentence => atspi_sys::ATSPI_TEXT_GRANULARITY_SENTENCE,
                    TextGranularity::Line => atspi_sys::ATSPI_TEXT_GRANULARITY_LINE,
                    TextGranularity::Paragraph => atspi_sys::ATSPI_TEXT_GRANULARITY_PARAGRAPH,
                    TextGranularity::__Unknown(value) => value,
                }
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiTextGranularity> for TextGranularity {
            fn from_glib(value: atspi_sys::AtspiTextGranularity) -> Self {
                match value {
                    0 => TextGranularity::Char,
                    1 => TextGranularity::Word,
                    2 => TextGranularity::Sentence,
                    3 => TextGranularity::Line,
                    4 => TextGranularity::Paragraph,
                    value => TextGranularity::__Unknown(value),
                }
            }
        }
        impl StaticType for TextGranularity {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_text_granularity_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for TextGranularity {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for TextGranularity {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_enum(value.to_glib_none().0))
            }
        }
        impl SetValue for TextGranularity {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_enum(value.to_glib_none_mut().0, this.to_glib())
            }
        }
    }
    pub use self::enums::CollectionMatchType;
    pub use self::enums::CollectionSortOrder;
    pub use self::enums::CollectionTreeTraversalType;
    pub use self::enums::ComponentLayer;
    pub use self::enums::CoordType;
    pub use self::enums::KeySynthType;
    pub use self::enums::RelationType;
    pub use self::enums::Role;
    pub use self::enums::StateType;
    pub use self::enums::TextBoundaryType;
    pub use self::enums::TextClipType;
    pub use self::enums::TextGranularity;
    mod flags {
        use atspi_sys;
        use glib::translate::*;
        use glib::value::FromValue;
        use glib::value::FromValueOptional;
        use glib::value::SetValue;
        use glib::value::Value;
        use glib::StaticType;
        use glib::Type;
        use gobject_sys;
        pub struct Cache {
            bits: u32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Cache {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Cache {
            #[inline]
            fn eq(&self, other: &Cache) -> bool {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Cache) -> bool {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Cache {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Cache {
            #[inline]
            fn clone(&self) -> Cache {
                {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Cache {
            #[inline]
            fn partial_cmp(&self, other: &Cache) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &Cache) -> bool {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &Cache) -> bool {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &Cache) -> bool {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &Cache) -> bool {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Cache {
            #[inline]
            fn cmp(&self, other: &Cache) -> ::core::cmp::Ordering {
                match *other {
                    Cache {
                        bits: ref __self_1_0,
                    } => match *self {
                        Cache {
                            bits: ref __self_0_0,
                        } => match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Cache {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Cache {
                        bits: ref __self_0_0,
                    } => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        impl ::bitflags::_core::fmt::Debug for Cache {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    #[inline]
                    fn NONE(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn PARENT(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn CHILDREN(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn NAME(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn DESCRIPTION(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn STATES(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn ROLE(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn INTERFACES(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn ATTRIBUTES(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn ALL(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn DEFAULT(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn UNDEFINED(&self) -> bool {
                        false
                    }
                }
                impl __BitFlags for Cache {
                    #[allow(deprecated)]
                    #[inline]
                    fn NONE(&self) -> bool {
                        if Self::NONE.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::NONE.bits == Self::NONE.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn PARENT(&self) -> bool {
                        if Self::PARENT.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::PARENT.bits == Self::PARENT.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn CHILDREN(&self) -> bool {
                        if Self::CHILDREN.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::CHILDREN.bits == Self::CHILDREN.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn NAME(&self) -> bool {
                        if Self::NAME.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::NAME.bits == Self::NAME.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn DESCRIPTION(&self) -> bool {
                        if Self::DESCRIPTION.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::DESCRIPTION.bits == Self::DESCRIPTION.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn STATES(&self) -> bool {
                        if Self::STATES.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::STATES.bits == Self::STATES.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn ROLE(&self) -> bool {
                        if Self::ROLE.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::ROLE.bits == Self::ROLE.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn INTERFACES(&self) -> bool {
                        if Self::INTERFACES.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::INTERFACES.bits == Self::INTERFACES.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn ATTRIBUTES(&self) -> bool {
                        if Self::ATTRIBUTES.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::ATTRIBUTES.bits == Self::ATTRIBUTES.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn ALL(&self) -> bool {
                        if Self::ALL.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::ALL.bits == Self::ALL.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn DEFAULT(&self) -> bool {
                        if Self::DEFAULT.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::DEFAULT.bits == Self::DEFAULT.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn UNDEFINED(&self) -> bool {
                        if Self::UNDEFINED.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::UNDEFINED.bits == Self::UNDEFINED.bits
                        }
                    }
                }
                let mut first = true;
                if <Cache as __BitFlags>::NONE(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("NONE")?;
                }
                if <Cache as __BitFlags>::PARENT(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("PARENT")?;
                }
                if <Cache as __BitFlags>::CHILDREN(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("CHILDREN")?;
                }
                if <Cache as __BitFlags>::NAME(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("NAME")?;
                }
                if <Cache as __BitFlags>::DESCRIPTION(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("DESCRIPTION")?;
                }
                if <Cache as __BitFlags>::STATES(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("STATES")?;
                }
                if <Cache as __BitFlags>::ROLE(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("ROLE")?;
                }
                if <Cache as __BitFlags>::INTERFACES(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("INTERFACES")?;
                }
                if <Cache as __BitFlags>::ATTRIBUTES(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("ATTRIBUTES")?;
                }
                if <Cache as __BitFlags>::ALL(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("ALL")?;
                }
                if <Cache as __BitFlags>::DEFAULT(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("DEFAULT")?;
                }
                if <Cache as __BitFlags>::UNDEFINED(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("UNDEFINED")?;
                }
                let extra_bits = self.bits & !Cache::all().bits();
                if extra_bits != 0 {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("0x")?;
                    ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                }
                if first {
                    f.write_str("(empty)")?;
                }
                Ok(())
            }
        }
        impl ::bitflags::_core::fmt::Binary for Cache {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::Octal for Cache {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::LowerHex for Cache {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::UpperHex for Cache {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
            }
        }
        #[allow(dead_code)]
        impl Cache {
            pub const NONE: Cache = Cache { bits: 0 };
            pub const PARENT: Cache = Cache { bits: 1 };
            pub const CHILDREN: Cache = Cache { bits: 2 };
            pub const NAME: Cache = Cache { bits: 4 };
            pub const DESCRIPTION: Cache = Cache { bits: 8 };
            pub const STATES: Cache = Cache { bits: 16 };
            pub const ROLE: Cache = Cache { bits: 32 };
            pub const INTERFACES: Cache = Cache { bits: 64 };
            pub const ATTRIBUTES: Cache = Cache { bits: 128 };
            pub const ALL: Cache = Cache {
                bits: 1_073_741_823,
            };
            pub const DEFAULT: Cache = Cache { bits: 127 };
            pub const UNDEFINED: Cache = Cache {
                bits: 1_073_741_824,
            };
            /// Returns an empty set of flags
            #[inline]
            pub const fn empty() -> Cache {
                Cache { bits: 0 }
            }
            /// Returns the set containing all flags.
            #[inline]
            pub const fn all() -> Cache {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    #[inline]
                    const NONE: u32 = 0;
                    #[inline]
                    const PARENT: u32 = 0;
                    #[inline]
                    const CHILDREN: u32 = 0;
                    #[inline]
                    const NAME: u32 = 0;
                    #[inline]
                    const DESCRIPTION: u32 = 0;
                    #[inline]
                    const STATES: u32 = 0;
                    #[inline]
                    const ROLE: u32 = 0;
                    #[inline]
                    const INTERFACES: u32 = 0;
                    #[inline]
                    const ATTRIBUTES: u32 = 0;
                    #[inline]
                    const ALL: u32 = 0;
                    #[inline]
                    const DEFAULT: u32 = 0;
                    #[inline]
                    const UNDEFINED: u32 = 0;
                }
                impl __BitFlags for Cache {
                    #[allow(deprecated)]
                    #[inline]
                    const NONE: u32 = Self::NONE.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const PARENT: u32 = Self::PARENT.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const CHILDREN: u32 = Self::CHILDREN.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const NAME: u32 = Self::NAME.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const DESCRIPTION: u32 = Self::DESCRIPTION.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const STATES: u32 = Self::STATES.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const ROLE: u32 = Self::ROLE.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const INTERFACES: u32 = Self::INTERFACES.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const ATTRIBUTES: u32 = Self::ATTRIBUTES.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const ALL: u32 = Self::ALL.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const DEFAULT: u32 = Self::DEFAULT.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const UNDEFINED: u32 = Self::UNDEFINED.bits;
                }
                Cache {
                    bits: <Cache as __BitFlags>::NONE
                        | <Cache as __BitFlags>::PARENT
                        | <Cache as __BitFlags>::CHILDREN
                        | <Cache as __BitFlags>::NAME
                        | <Cache as __BitFlags>::DESCRIPTION
                        | <Cache as __BitFlags>::STATES
                        | <Cache as __BitFlags>::ROLE
                        | <Cache as __BitFlags>::INTERFACES
                        | <Cache as __BitFlags>::ATTRIBUTES
                        | <Cache as __BitFlags>::ALL
                        | <Cache as __BitFlags>::DEFAULT
                        | <Cache as __BitFlags>::UNDEFINED,
                }
            }
            /// Returns the raw value of the flags currently stored.
            #[inline]
            pub const fn bits(&self) -> u32 {
                self.bits
            }
            /// Convert from underlying bit representation, unless that
            /// representation contains bits that do not correspond to a flag.
            #[inline]
            pub fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Cache> {
                if (bits & !Cache::all().bits()) == 0 {
                    ::bitflags::_core::option::Option::Some(Cache { bits })
                } else {
                    ::bitflags::_core::option::Option::None
                }
            }
            /// Convert from underlying bit representation, dropping any bits
            /// that do not correspond to flags.
            #[inline]
            pub const fn from_bits_truncate(bits: u32) -> Cache {
                Cache {
                    bits: bits & Cache::all().bits,
                }
            }
            /// Convert from underlying bit representation, preserving all
            /// bits (even those not corresponding to a defined flag).
            #[inline]
            pub const unsafe fn from_bits_unchecked(bits: u32) -> Cache {
                Cache { bits }
            }
            /// Returns `true` if no flags are currently stored.
            #[inline]
            pub const fn is_empty(&self) -> bool {
                self.bits() == Cache::empty().bits()
            }
            /// Returns `true` if all flags are currently set.
            #[inline]
            pub const fn is_all(&self) -> bool {
                self.bits == Cache::all().bits
            }
            /// Returns `true` if there are flags common to both `self` and `other`.
            #[inline]
            pub const fn intersects(&self, other: Cache) -> bool {
                !Cache {
                    bits: self.bits & other.bits,
                }
                .is_empty()
            }
            /// Returns `true` all of the flags in `other` are contained within `self`.
            #[inline]
            pub const fn contains(&self, other: Cache) -> bool {
                (self.bits & other.bits) == other.bits
            }
            /// Inserts the specified flags in-place.
            #[inline]
            pub fn insert(&mut self, other: Cache) {
                self.bits |= other.bits;
            }
            /// Removes the specified flags in-place.
            #[inline]
            pub fn remove(&mut self, other: Cache) {
                self.bits &= !other.bits;
            }
            /// Toggles the specified flags in-place.
            #[inline]
            pub fn toggle(&mut self, other: Cache) {
                self.bits ^= other.bits;
            }
            /// Inserts or removes the specified flags depending on the passed value.
            #[inline]
            pub fn set(&mut self, other: Cache, value: bool) {
                if value {
                    self.insert(other);
                } else {
                    self.remove(other);
                }
            }
        }
        impl ::bitflags::_core::ops::BitOr for Cache {
            type Output = Cache;
            /// Returns the union of the two sets of flags.
            #[inline]
            fn bitor(self, other: Cache) -> Cache {
                Cache {
                    bits: self.bits | other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitOrAssign for Cache {
            /// Adds the set of flags.
            #[inline]
            fn bitor_assign(&mut self, other: Cache) {
                self.bits |= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitXor for Cache {
            type Output = Cache;
            /// Returns the left flags, but with all the right flags toggled.
            #[inline]
            fn bitxor(self, other: Cache) -> Cache {
                Cache {
                    bits: self.bits ^ other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitXorAssign for Cache {
            /// Toggles the set of flags.
            #[inline]
            fn bitxor_assign(&mut self, other: Cache) {
                self.bits ^= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitAnd for Cache {
            type Output = Cache;
            /// Returns the intersection between the two sets of flags.
            #[inline]
            fn bitand(self, other: Cache) -> Cache {
                Cache {
                    bits: self.bits & other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitAndAssign for Cache {
            /// Disables all flags disabled in the set.
            #[inline]
            fn bitand_assign(&mut self, other: Cache) {
                self.bits &= other.bits;
            }
        }
        impl ::bitflags::_core::ops::Sub for Cache {
            type Output = Cache;
            /// Returns the set difference of the two sets of flags.
            #[inline]
            fn sub(self, other: Cache) -> Cache {
                Cache {
                    bits: self.bits & !other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::SubAssign for Cache {
            /// Disables all flags enabled in the set.
            #[inline]
            fn sub_assign(&mut self, other: Cache) {
                self.bits &= !other.bits;
            }
        }
        impl ::bitflags::_core::ops::Not for Cache {
            type Output = Cache;
            /// Returns the complement of this set of flags.
            #[inline]
            fn not(self) -> Cache {
                Cache { bits: !self.bits } & Cache::all()
            }
        }
        impl ::bitflags::_core::iter::Extend<Cache> for Cache {
            fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Cache>>(
                &mut self,
                iterator: T,
            ) {
                for item in iterator {
                    self.insert(item)
                }
            }
        }
        impl ::bitflags::_core::iter::FromIterator<Cache> for Cache {
            fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Cache>>(
                iterator: T,
            ) -> Cache {
                let mut result = Self::empty();
                result.extend(iterator);
                result
            }
        }
        #[doc(hidden)]
        impl ToGlib for Cache {
            type GlibType = atspi_sys::AtspiCache;
            fn to_glib(&self) -> atspi_sys::AtspiCache {
                self.bits()
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiCache> for Cache {
            fn from_glib(value: atspi_sys::AtspiCache) -> Cache {
                Cache::from_bits_truncate(value)
            }
        }
        impl StaticType for Cache {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_cache_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for Cache {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for Cache {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
            }
        }
        impl SetValue for Cache {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
            }
        }
        pub struct KeyListenerSyncType {
            bits: u32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for KeyListenerSyncType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for KeyListenerSyncType {
            #[inline]
            fn eq(&self, other: &KeyListenerSyncType) -> bool {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &KeyListenerSyncType) -> bool {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for KeyListenerSyncType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for KeyListenerSyncType {
            #[inline]
            fn clone(&self) -> KeyListenerSyncType {
                {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for KeyListenerSyncType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &KeyListenerSyncType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
            #[inline]
            fn lt(&self, other: &KeyListenerSyncType) -> bool {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
            #[inline]
            fn le(&self, other: &KeyListenerSyncType) -> bool {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn gt(&self, other: &KeyListenerSyncType) -> bool {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                    },
                }
            }
            #[inline]
            fn ge(&self, other: &KeyListenerSyncType) -> bool {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for KeyListenerSyncType {
            #[inline]
            fn cmp(&self, other: &KeyListenerSyncType) -> ::core::cmp::Ordering {
                match *other {
                    KeyListenerSyncType {
                        bits: ref __self_1_0,
                    } => match *self {
                        KeyListenerSyncType {
                            bits: ref __self_0_0,
                        } => match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for KeyListenerSyncType {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    KeyListenerSyncType {
                        bits: ref __self_0_0,
                    } => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        impl ::bitflags::_core::fmt::Debug for KeyListenerSyncType {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    #[inline]
                    fn NOSYNC(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn SYNCHRONOUS(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn CANCONSUME(&self) -> bool {
                        false
                    }
                    #[inline]
                    fn ALL_WINDOWS(&self) -> bool {
                        false
                    }
                }
                impl __BitFlags for KeyListenerSyncType {
                    #[allow(deprecated)]
                    #[inline]
                    fn NOSYNC(&self) -> bool {
                        if Self::NOSYNC.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::NOSYNC.bits == Self::NOSYNC.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn SYNCHRONOUS(&self) -> bool {
                        if Self::SYNCHRONOUS.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::SYNCHRONOUS.bits == Self::SYNCHRONOUS.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn CANCONSUME(&self) -> bool {
                        if Self::CANCONSUME.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::CANCONSUME.bits == Self::CANCONSUME.bits
                        }
                    }
                    #[allow(deprecated)]
                    #[inline]
                    fn ALL_WINDOWS(&self) -> bool {
                        if Self::ALL_WINDOWS.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::ALL_WINDOWS.bits == Self::ALL_WINDOWS.bits
                        }
                    }
                }
                let mut first = true;
                if <KeyListenerSyncType as __BitFlags>::NOSYNC(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("NOSYNC")?;
                }
                if <KeyListenerSyncType as __BitFlags>::SYNCHRONOUS(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("SYNCHRONOUS")?;
                }
                if <KeyListenerSyncType as __BitFlags>::CANCONSUME(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("CANCONSUME")?;
                }
                if <KeyListenerSyncType as __BitFlags>::ALL_WINDOWS(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("ALL_WINDOWS")?;
                }
                let extra_bits = self.bits & !KeyListenerSyncType::all().bits();
                if extra_bits != 0 {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("0x")?;
                    ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                }
                if first {
                    f.write_str("(empty)")?;
                }
                Ok(())
            }
        }
        impl ::bitflags::_core::fmt::Binary for KeyListenerSyncType {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::Octal for KeyListenerSyncType {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::LowerHex for KeyListenerSyncType {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::UpperHex for KeyListenerSyncType {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
            }
        }
        #[allow(dead_code)]
        impl KeyListenerSyncType {
            pub const NOSYNC: KeyListenerSyncType = KeyListenerSyncType { bits: 0 };
            pub const SYNCHRONOUS: KeyListenerSyncType = KeyListenerSyncType { bits: 1 };
            pub const CANCONSUME: KeyListenerSyncType = KeyListenerSyncType { bits: 2 };
            pub const ALL_WINDOWS: KeyListenerSyncType = KeyListenerSyncType { bits: 4 };
            /// Returns an empty set of flags
            #[inline]
            pub const fn empty() -> KeyListenerSyncType {
                KeyListenerSyncType { bits: 0 }
            }
            /// Returns the set containing all flags.
            #[inline]
            pub const fn all() -> KeyListenerSyncType {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    #[inline]
                    const NOSYNC: u32 = 0;
                    #[inline]
                    const SYNCHRONOUS: u32 = 0;
                    #[inline]
                    const CANCONSUME: u32 = 0;
                    #[inline]
                    const ALL_WINDOWS: u32 = 0;
                }
                impl __BitFlags for KeyListenerSyncType {
                    #[allow(deprecated)]
                    #[inline]
                    const NOSYNC: u32 = Self::NOSYNC.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const SYNCHRONOUS: u32 = Self::SYNCHRONOUS.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const CANCONSUME: u32 = Self::CANCONSUME.bits;
                    #[allow(deprecated)]
                    #[inline]
                    const ALL_WINDOWS: u32 = Self::ALL_WINDOWS.bits;
                }
                KeyListenerSyncType {
                    bits: <KeyListenerSyncType as __BitFlags>::NOSYNC
                        | <KeyListenerSyncType as __BitFlags>::SYNCHRONOUS
                        | <KeyListenerSyncType as __BitFlags>::CANCONSUME
                        | <KeyListenerSyncType as __BitFlags>::ALL_WINDOWS,
                }
            }
            /// Returns the raw value of the flags currently stored.
            #[inline]
            pub const fn bits(&self) -> u32 {
                self.bits
            }
            /// Convert from underlying bit representation, unless that
            /// representation contains bits that do not correspond to a flag.
            #[inline]
            pub fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<KeyListenerSyncType> {
                if (bits & !KeyListenerSyncType::all().bits()) == 0 {
                    ::bitflags::_core::option::Option::Some(KeyListenerSyncType { bits })
                } else {
                    ::bitflags::_core::option::Option::None
                }
            }
            /// Convert from underlying bit representation, dropping any bits
            /// that do not correspond to flags.
            #[inline]
            pub const fn from_bits_truncate(bits: u32) -> KeyListenerSyncType {
                KeyListenerSyncType {
                    bits: bits & KeyListenerSyncType::all().bits,
                }
            }
            /// Convert from underlying bit representation, preserving all
            /// bits (even those not corresponding to a defined flag).
            #[inline]
            pub const unsafe fn from_bits_unchecked(bits: u32) -> KeyListenerSyncType {
                KeyListenerSyncType { bits }
            }
            /// Returns `true` if no flags are currently stored.
            #[inline]
            pub const fn is_empty(&self) -> bool {
                self.bits() == KeyListenerSyncType::empty().bits()
            }
            /// Returns `true` if all flags are currently set.
            #[inline]
            pub const fn is_all(&self) -> bool {
                self.bits == KeyListenerSyncType::all().bits
            }
            /// Returns `true` if there are flags common to both `self` and `other`.
            #[inline]
            pub const fn intersects(&self, other: KeyListenerSyncType) -> bool {
                !KeyListenerSyncType {
                    bits: self.bits & other.bits,
                }
                .is_empty()
            }
            /// Returns `true` all of the flags in `other` are contained within `self`.
            #[inline]
            pub const fn contains(&self, other: KeyListenerSyncType) -> bool {
                (self.bits & other.bits) == other.bits
            }
            /// Inserts the specified flags in-place.
            #[inline]
            pub fn insert(&mut self, other: KeyListenerSyncType) {
                self.bits |= other.bits;
            }
            /// Removes the specified flags in-place.
            #[inline]
            pub fn remove(&mut self, other: KeyListenerSyncType) {
                self.bits &= !other.bits;
            }
            /// Toggles the specified flags in-place.
            #[inline]
            pub fn toggle(&mut self, other: KeyListenerSyncType) {
                self.bits ^= other.bits;
            }
            /// Inserts or removes the specified flags depending on the passed value.
            #[inline]
            pub fn set(&mut self, other: KeyListenerSyncType, value: bool) {
                if value {
                    self.insert(other);
                } else {
                    self.remove(other);
                }
            }
        }
        impl ::bitflags::_core::ops::BitOr for KeyListenerSyncType {
            type Output = KeyListenerSyncType;
            /// Returns the union of the two sets of flags.
            #[inline]
            fn bitor(self, other: KeyListenerSyncType) -> KeyListenerSyncType {
                KeyListenerSyncType {
                    bits: self.bits | other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitOrAssign for KeyListenerSyncType {
            /// Adds the set of flags.
            #[inline]
            fn bitor_assign(&mut self, other: KeyListenerSyncType) {
                self.bits |= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitXor for KeyListenerSyncType {
            type Output = KeyListenerSyncType;
            /// Returns the left flags, but with all the right flags toggled.
            #[inline]
            fn bitxor(self, other: KeyListenerSyncType) -> KeyListenerSyncType {
                KeyListenerSyncType {
                    bits: self.bits ^ other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitXorAssign for KeyListenerSyncType {
            /// Toggles the set of flags.
            #[inline]
            fn bitxor_assign(&mut self, other: KeyListenerSyncType) {
                self.bits ^= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitAnd for KeyListenerSyncType {
            type Output = KeyListenerSyncType;
            /// Returns the intersection between the two sets of flags.
            #[inline]
            fn bitand(self, other: KeyListenerSyncType) -> KeyListenerSyncType {
                KeyListenerSyncType {
                    bits: self.bits & other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitAndAssign for KeyListenerSyncType {
            /// Disables all flags disabled in the set.
            #[inline]
            fn bitand_assign(&mut self, other: KeyListenerSyncType) {
                self.bits &= other.bits;
            }
        }
        impl ::bitflags::_core::ops::Sub for KeyListenerSyncType {
            type Output = KeyListenerSyncType;
            /// Returns the set difference of the two sets of flags.
            #[inline]
            fn sub(self, other: KeyListenerSyncType) -> KeyListenerSyncType {
                KeyListenerSyncType {
                    bits: self.bits & !other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::SubAssign for KeyListenerSyncType {
            /// Disables all flags enabled in the set.
            #[inline]
            fn sub_assign(&mut self, other: KeyListenerSyncType) {
                self.bits &= !other.bits;
            }
        }
        impl ::bitflags::_core::ops::Not for KeyListenerSyncType {
            type Output = KeyListenerSyncType;
            /// Returns the complement of this set of flags.
            #[inline]
            fn not(self) -> KeyListenerSyncType {
                KeyListenerSyncType { bits: !self.bits } & KeyListenerSyncType::all()
            }
        }
        impl ::bitflags::_core::iter::Extend<KeyListenerSyncType> for KeyListenerSyncType {
            fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = KeyListenerSyncType>>(
                &mut self,
                iterator: T,
            ) {
                for item in iterator {
                    self.insert(item)
                }
            }
        }
        impl ::bitflags::_core::iter::FromIterator<KeyListenerSyncType> for KeyListenerSyncType {
            fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = KeyListenerSyncType>>(
                iterator: T,
            ) -> KeyListenerSyncType {
                let mut result = Self::empty();
                result.extend(iterator);
                result
            }
        }
        #[doc(hidden)]
        impl ToGlib for KeyListenerSyncType {
            type GlibType = atspi_sys::AtspiKeyListenerSyncType;
            fn to_glib(&self) -> atspi_sys::AtspiKeyListenerSyncType {
                self.bits()
            }
        }
        #[doc(hidden)]
        impl FromGlib<atspi_sys::AtspiKeyListenerSyncType> for KeyListenerSyncType {
            fn from_glib(value: atspi_sys::AtspiKeyListenerSyncType) -> KeyListenerSyncType {
                KeyListenerSyncType::from_bits_truncate(value)
            }
        }
        impl StaticType for KeyListenerSyncType {
            fn static_type() -> Type {
                unsafe { from_glib(atspi_sys::atspi_key_listener_sync_type_get_type()) }
            }
        }
        impl<'a> FromValueOptional<'a> for KeyListenerSyncType {
            unsafe fn from_value_optional(value: &Value) -> Option<Self> {
                Some(FromValue::from_value(value))
            }
        }
        impl<'a> FromValue<'a> for KeyListenerSyncType {
            unsafe fn from_value(value: &Value) -> Self {
                from_glib(gobject_sys::g_value_get_flags(value.to_glib_none().0))
            }
        }
        impl SetValue for KeyListenerSyncType {
            unsafe fn set_value(value: &mut Value, this: &Self) {
                gobject_sys::g_value_set_flags(value.to_glib_none_mut().0, this.to_glib())
            }
        }
    }
    pub use self::flags::Cache;
    pub use self::flags::KeyListenerSyncType;
    mod alias {
        #[allow(unused_imports)]
        use auto::*;
        pub type ControllerEventMask = u32;
        pub type DeviceEventMask = u32;
        pub type KeyEventMask = u32;
        pub type KeyMaskType = u32;
        pub type KeystrokeListener = ();
    }
    pub use self::alias::ControllerEventMask;
    pub use self::alias::DeviceEventMask;
    pub use self::alias::KeyEventMask;
    pub use self::alias::KeyMaskType;
    pub use self::alias::KeystrokeListener;
    #[doc(hidden)]
    pub mod traits {
        pub use super::AccessibleExt;
        pub use super::ActionExt;
        pub use super::CollectionExt;
        pub use super::ComponentExt;
        pub use super::DeviceListenerExt;
        pub use super::DocumentExt;
        pub use super::EditableTextExt;
        pub use super::HyperlinkExt;
        pub use super::HypertextExt;
        pub use super::ImageExt;
        pub use super::RelationExt;
        pub use super::SelectionExt;
        pub use super::StateSetExt;
        pub use super::TableCellExt;
        pub use super::TableExt;
        pub use super::TextExt;
        pub use super::ValueExt;
    }
}
pub use auto::*;
use glib::Error;
